{"version":3,"file":"index.js","sources":["../src/lib/expressions/embedding.ts","../src/lib/expressions/functions.ts","../src/lib/expressions/parser.ts","../src/lib/utils/path.ts","../src/lib/expressions/evaluator.ts","../src/lib/expressions/index.ts","../src/types.ts","../src/lib/parser/ast.ts","../src/lib/workflowschema/uses.ts","../src/lib/workflow/normalize.ts","../src/lib/expressions/types.ts","../src/lib/expressions/validator.ts","../src/lib/parser/schema.ts","../src/lib/parser/validator.ts","../src/lib/parser/parser.ts","../src/lib/parser/complete.ts","../src/lib/expressions/completion.ts","../src/lib/parser/hover.ts","../src/lib/utils/deepMerge.ts","../src/lib/events/eventPayload.ts","../src/lib/workflowschema/contextProvider.ts","../src/lib/workflowschema/contextCompletion.ts","../src/lib/workflowschema/schema/events.ts","../src/lib/workflowschema/schema/needs.ts","../src/lib/workflowschema/valueProvider/actionsInputProvider.ts","../src/lib/workflowschema/workflowSchema.ts","../src/lib/utils/cache.ts"],"sourcesContent":["export const expressionMarker = /\\$\\{\\{(.*?)\\}\\}/gm;\n\nexport function containsExpression(input: string): boolean {\n  return input?.match && input.match(expressionMarker) !== null;\n}\n\nexport function removeExpressionMarker(input: string): string {\n  return input.replace(expressionMarker, (_, g) => g);\n}\n\nexport function iterateExpressions(\n  input: string,\n  f: (expression: string, pos: number, length: number) => void\n) {\n  for (const match of Array.from(input.matchAll(expressionMarker))) {\n    f(match[0], match.index!, match.length);\n  }\n}\n","const funcDescription = {\n  toJSON:\n    \"Returns a pretty-print JSON representation of `value`. You can use this function to debug the information provided in contexts.\",\n};\n\nexport const Undetermined = {};\n\nexport function getFunctionDescription(f: string): string | undefined {\n  return funcDescription[f];\n}\n\nexport function contains<T>(haystack: T | T[], needle: T): boolean {\n  if (Array.isArray(haystack)) {\n    return haystack.indexOf(needle) !== -1;\n  } else {\n    return (\n      (\"\" + haystack)\n        .toLocaleLowerCase()\n        .indexOf((\"\" + needle).toLocaleLowerCase()) !== -1\n    );\n  }\n}\n\nexport function startsWith(haystack: string, needle: string): boolean {\n  return haystack.startsWith(needle);\n}\n\nexport function endsWith(haystack: string, needle: string): boolean {\n  return haystack.endsWith(needle);\n}\n\nexport function join<T>(arr: T[], separator?: string): string {\n  return arr.join(separator);\n}\n\nexport function toJSON(input: unknown): string {\n  return JSON.stringify(input);\n}\n\nexport function fromJSON(input: string | typeof Undetermined): unknown {\n  if (typeof input === \"string\") {\n    return JSON.parse(input);\n  }\n\n  if (input === Undetermined) {\n    return Undetermined;\n  }\n\n  throw new Error(\"Unknown input for `fromJSON`\");\n}\n\nexport function hashFiles(path: string[]): string {\n  return `sha-256-hash-for-${path.join()}`;\n}\n\nexport function format(format: string, ...params: string[]): string {\n  let idx = 0;\n  format = format.replace(/(\\{\\d+\\})/gm, () => params[idx++]);\n  return format.replace(\"{{\", \"{\").replace(\"}}\", \"}\");\n}\n\nexport function always(): boolean {\n  return true;\n}\n\nexport function failure() {\n  return Undetermined;\n}\n\nexport function success() {\n  return Undetermined;\n}\n\nexport function cancelled() {\n  return Undetermined;\n}\n","import * as chevrotain from \"chevrotain\";\n\n///////\n// Copy the content between here,\n\nconst True = chevrotain.createToken({ name: \"True\", pattern: /true/ });\nconst False = chevrotain.createToken({ name: \"False\", pattern: /false/ });\nconst Null = chevrotain.createToken({ name: \"Null\", pattern: /null/ });\nconst LParens = chevrotain.createToken({ name: \"LParens\", pattern: /\\(/ });\nconst RParens = chevrotain.createToken({ name: \"RParens\", pattern: /\\)/ });\nconst LSquare = chevrotain.createToken({ name: \"LSquare\", pattern: /\\[/ });\nconst RSquare = chevrotain.createToken({ name: \"RSquare\", pattern: /]/ });\nconst Comma = chevrotain.createToken({ name: \"Comma\", pattern: /,/ });\n\n/**\n * Expressions cannot use arbitrary variables, everything needs to be access via a context,\n * so define all supported ones.\n * see https://help.github.com/en/actions/reference/context-and-expression-syntax-for-github-actions#contexts\n */\nexport const Dot = chevrotain.createToken({ name: \"Dot\", pattern: /\\./ });\nexport const ContextMemberOrKeyword = chevrotain.createToken({\n  name: \"ContextMemberOrKeyword\",\n  pattern: chevrotain.Lexer.NA,\n});\nexport const ContextMember = chevrotain.createToken({\n  name: \"ContextMember\",\n  pattern: /[a-zA-Z_][a-zA-Z0-9-_]*/,\n  categories: ContextMemberOrKeyword,\n});\nexport const Context = chevrotain.createToken({\n  name: \"Context\",\n  pattern: chevrotain.Lexer.NA,\n  longer_alt: ContextMember,\n});\nexport const Contexts = [\n  \"github\",\n  \"env\",\n  \"job\",\n  \"steps\",\n  \"runner\",\n  \"secrets\",\n  \"strategy\",\n  \"matrix\",\n  \"needs\",\n].map((c) =>\n  chevrotain.createToken({\n    name: `Context${c}`,\n    pattern: new RegExp(`${c}`),\n    categories: [Context, ContextMemberOrKeyword],\n    longer_alt: ContextMember,\n  })\n);\n\n//\n// Operators\n//\nexport const Operator = chevrotain.createToken({\n  name: \"Operator\",\n  pattern: chevrotain.Lexer.NA,\n  longer_alt: ContextMember,\n});\nexport const And = chevrotain.createToken({\n  name: \"And\",\n  pattern: /&&/,\n  categories: Operator,\n});\nexport const Or = chevrotain.createToken({\n  name: \"Or\",\n  pattern: /\\|\\|/,\n  categories: Operator,\n});\nexport const Eq = chevrotain.createToken({\n  name: \"Eq\",\n  pattern: /==/,\n  categories: Operator,\n});\nexport const NEq = chevrotain.createToken({\n  name: \"NotEq\",\n  pattern: /!=/,\n  categories: Operator,\n});\nexport const LT = chevrotain.createToken({\n  name: \"LT\",\n  pattern: /</,\n  categories: Operator,\n});\nexport const LTE = chevrotain.createToken({\n  name: \"LTE\",\n  pattern: /<=/,\n  categories: Operator,\n});\nexport const GT = chevrotain.createToken({\n  name: \"GT\",\n  pattern: />/,\n  categories: Operator,\n});\nexport const GTE = chevrotain.createToken({\n  name: \"GTE\",\n  pattern: />=/,\n  categories: Operator,\n});\nexport const Not = chevrotain.createToken({\n  name: \"Not\",\n  pattern: /!/,\n  categories: Operator,\n});\n\n//\n// Functions\n//\n// TODO: Adding all functions as tokens might not be the best idea, but this way we get validation during parsing\nexport const Function = chevrotain.createToken({\n  name: \"Function\",\n  pattern: chevrotain.Lexer.NA,\n  longer_alt: ContextMember,\n});\nexport const contains = chevrotain.createToken({\n  name: \"contains\",\n  pattern: /contains/,\n  categories: [Function, ContextMemberOrKeyword],\n  longer_alt: ContextMember,\n});\nexport const startsWith = chevrotain.createToken({\n  name: \"startsWith\",\n  pattern: /startsWith/,\n  categories: [Function, ContextMemberOrKeyword],\n  longer_alt: ContextMember,\n});\nexport const endsWith = chevrotain.createToken({\n  name: \"endsWith\",\n  pattern: /endsWith/,\n  categories: [Function, ContextMemberOrKeyword],\n  longer_alt: ContextMember,\n});\nexport const join = chevrotain.createToken({\n  name: \"join\",\n  pattern: /join/,\n  categories: [Function, ContextMemberOrKeyword],\n  longer_alt: ContextMember,\n});\nexport const toJSON = chevrotain.createToken({\n  name: \"toJSON\",\n  pattern: /toJSON/,\n  categories: [Function, ContextMemberOrKeyword],\n  longer_alt: ContextMember,\n});\nexport const fromJSON = chevrotain.createToken({\n  name: \"fromJSON\",\n  pattern: /fromJSON/,\n  categories: [Function, ContextMemberOrKeyword],\n  longer_alt: ContextMember,\n});\nexport const hashFiles = chevrotain.createToken({\n  name: \"hashFiles\",\n  pattern: /hashFiles/,\n  categories: [Function, ContextMemberOrKeyword],\n  longer_alt: ContextMember,\n});\nexport const success = chevrotain.createToken({\n  name: \"success\",\n  pattern: /success/,\n  categories: [Function, ContextMemberOrKeyword],\n  longer_alt: ContextMember,\n});\nexport const always = chevrotain.createToken({\n  name: \"always\",\n  pattern: /always/,\n  categories: [Function, ContextMemberOrKeyword],\n  longer_alt: ContextMember,\n});\nexport const failure = chevrotain.createToken({\n  name: \"failure\",\n  pattern: /failure/,\n  categories: [Function, ContextMemberOrKeyword],\n  longer_alt: ContextMember,\n});\nexport const format = chevrotain.createToken({\n  name: \"format\",\n  pattern: /format/,\n  categories: [Function, ContextMemberOrKeyword],\n  longer_alt: ContextMember,\n});\nexport const cancelled = chevrotain.createToken({\n  name: \"cancelled\",\n  pattern: /cancelled/,\n  categories: [Function, ContextMemberOrKeyword],\n  longer_alt: ContextMember,\n});\nconst Functions = [\n  contains,\n  startsWith,\n  endsWith,\n  join,\n  toJSON,\n  fromJSON,\n  hashFiles,\n  success,\n  always,\n  failure,\n  format,\n  cancelled,\n];\n\nexport const StringLiteral = chevrotain.createToken({\n  name: \"StringLiteral\",\n  //pattern: /'(:?[^'']|\\\\(:?[bfnrtv\\\\/]|u[0-9a-fA-F]{4}))*'/,\n  pattern: /'((?:''|[^'])*)'/,\n});\nexport const NumberLiteral = chevrotain.createToken({\n  name: \"NumberLiteral\",\n  pattern: /-?(0|[1-9]\\d*)(\\.\\d+)?([eE][+-]?\\d+)?/,\n});\nexport const WhiteSpace = chevrotain.createToken({\n  name: \"WhiteSpace\",\n  pattern: /[ \\t\\n\\r]+/,\n  group: chevrotain.Lexer.SKIPPED,\n});\n\nconst allTokens = [\n  WhiteSpace,\n  NumberLiteral,\n\n  // Built-in functions\n  Function,\n  contains,\n  startsWith,\n  format,\n  endsWith,\n  join,\n  toJSON,\n  fromJSON,\n  hashFiles,\n  success,\n  always,\n  cancelled,\n  failure,\n\n  StringLiteral,\n  LParens,\n  RParens,\n  LSquare,\n  RSquare,\n  Comma,\n\n  // Operators\n  Operator,\n  And,\n  Or,\n  Eq,\n  NEq,\n  LTE,\n  LT,\n  GTE,\n  GT,\n  Not,\n\n  // Literals\n  True,\n  False,\n  Null,\n\n  // Contexts (github, env, etc.)\n  Context,\n  ...Contexts,\n  Dot,\n  ContextMemberOrKeyword,\n  ContextMember,\n];\nconst ExpressionLexer = new chevrotain.Lexer(allTokens);\n\nexport class ExpressionParser extends chevrotain.CstParser {\n  constructor() {\n    super(allTokens);\n    this.performSelfAnalysis();\n  }\n\n  expression = this.RULE(\"expression\", () => {\n    //this.OPTION(() => {\n    this.SUBRULE1(this.subExpression, { LABEL: \"lhs\" });\n    this.MANY(() => {\n      this.CONSUME(Operator);\n      this.SUBRULE2(this.subExpression, { LABEL: \"rhs\" });\n    });\n    //});\n  });\n\n  subExpression = this.RULE(\"subExpression\", () => {\n    this.OPTION(() => this.CONSUME(Not));\n    this.OR([\n      { ALT: () => this.SUBRULE(this.logicalGrouping) },\n      { ALT: () => this.SUBRULE(this.functionCall) },\n      { ALT: () => this.SUBRULE(this.contextAccess) },\n      { ALT: () => this.SUBRULE(this.value) },\n      { ALT: () => this.SUBRULE(this.array) },\n    ]);\n  });\n\n  contextAccess = this.RULE(\"contextAccess\", () => {\n    this.OR(\n      Contexts.map((f) => ({\n        ALT: () => this.CONSUME(f),\n      }))\n    );\n\n    this.MANY(() => {\n      this.SUBRULE(this.contextMember);\n    });\n  });\n\n  contextMember = this.RULE(\"contextMember\", () => {\n    this.OR([\n      { ALT: () => this.SUBRULE(this.contextDotMember) },\n      { ALT: () => this.SUBRULE(this.contextBoxMember) },\n    ]);\n  });\n\n  contextDotMember = this.RULE(\"contextDotMember\", () => {\n    this.CONSUME(Dot);\n    this.CONSUME(ContextMemberOrKeyword);\n  });\n\n  contextBoxMember = this.RULE(\"contextBoxMember\", () => {\n    this.CONSUME(LSquare);\n    this.SUBRULE(this.expression);\n    this.CONSUME(RSquare);\n  });\n\n  array = this.RULE(\"array\", () => {\n    this.CONSUME(LSquare);\n    this.MANY_SEP({\n      SEP: Comma,\n      DEF: () => {\n        this.SUBRULE(this.subExpression);\n      },\n    });\n    this.CONSUME(RSquare);\n  });\n\n  logicalGrouping = this.RULE(\"logicalGrouping\", () => {\n    this.CONSUME(LParens);\n    this.SUBRULE(this.expression);\n    this.CONSUME(RParens);\n  });\n\n  functionCall = this.RULE(\"functionCall\", () => {\n    this.OR1([\n      // fromJSON is the only function that might return an object, and then allow context access\n      {\n        ALT: () => {\n          this.CONSUME(fromJSON);\n          this.SUBRULE1(this.functionParameters);\n          this.OPTION(() => this.SUBRULE(this.contextMember));\n        },\n      },\n      {\n        ALT: () => {\n          this.OR2(\n            Functions.filter((f) => f !== fromJSON).map((f) => ({\n              ALT: () => this.CONSUME(f),\n            }))\n          );\n\n          this.SUBRULE2(this.functionParameters);\n        },\n      },\n    ]);\n  });\n\n  functionParameters = this.RULE(\"functionParameters\", () => {\n    this.CONSUME(LParens);\n    this.MANY_SEP({\n      SEP: Comma,\n      DEF: () => {\n        this.SUBRULE(this.expression);\n      },\n    });\n    this.CONSUME(RParens);\n  });\n\n  value = this.RULE(\"value\", () => {\n    this.OR([\n      { ALT: () => this.CONSUME(StringLiteral) },\n      { ALT: () => this.CONSUME(NumberLiteral) },\n      { ALT: () => this.SUBRULE(this.booleanValue) },\n      { ALT: () => this.CONSUME(Null) },\n    ]);\n  });\n\n  booleanValue = this.RULE(\"booleanValue\", () => {\n    this.OR([\n      { ALT: () => this.CONSUME(True) },\n      { ALT: () => this.CONSUME(False) },\n    ]);\n  });\n}\n\n// return {\n//   lexer: ExpressionLexer,\n//   parser: ExpressionParser,\n//   defaultRule: \"expression\",\n// };\n// and here to the playground for visualization.\n//////////\n\n// reuse the same parser instance.\nexport const defaultRule = \"expression\";\nexport const parser = new ExpressionParser();\nexport const BaseCstVisitor = parser.getBaseCstVisitorConstructor();\nexport { ExpressionLexer };\n","export type PropertyPath = (string | number | [string, number])[];\n\nexport function iteratePath(\n  path: PropertyPath,\n  obj: any,\n  f?: (x: any) => void\n) {\n  for (const p of path) {\n    if (p == \"$\") continue;\n    if (!obj) break;\n\n    f && f(obj);\n\n    if (typeof p === \"string\" || typeof p === \"number\") {\n      obj = obj[p];\n    } else {\n      // Sequence\n      obj = obj[p[0]][p[1]];\n    }\n  }\n\n  return obj;\n}\n","import * as Functions from \"./functions\";\n\nimport {\n  And,\n  BaseCstVisitor,\n  Contexts,\n  Eq,\n  GT,\n  GTE,\n  LT,\n  LTE,\n  NEq,\n  Or,\n} from \"./parser\";\nimport { PropertyPath, iteratePath } from \"../utils/path\";\n\nimport { ContextProvider } from \"./types\";\nimport { tokenMatcher } from \"chevrotain\";\n\nexport interface ExpressionContext {\n  contextProvider: ContextProvider;\n}\n\n/**\n * This evaluates an expression by operation on the CST produced by the parser.\n */\nexport class ExpressionEvaluator extends BaseCstVisitor {\n  constructor() {\n    super();\n\n    this.validateVisitor();\n  }\n\n  expression(ctx: any, context: ExpressionContext) {\n    let result = this.visit(ctx.lhs, context);\n\n    if (ctx.rhs) {\n      ctx.rhs.forEach((rhsOperand, idx) => {\n        let rhsResult = this.visit(rhsOperand, context);\n        const operator = ctx.Operator[idx];\n\n        // Coerce types\n        if (typeof result != typeof rhsResult) {\n          result = this._coerceValue(result);\n          rhsResult = this._coerceValue(rhsResult);\n        }\n\n        switch (true) {\n          // ==\n          case tokenMatcher(operator, Eq):\n            result = result == rhsResult;\n            break;\n\n          // !=\n          case tokenMatcher(operator, NEq):\n            result = result != rhsResult;\n            break;\n\n          // &&\n          case tokenMatcher(operator, And):\n            result = result && rhsResult;\n            break;\n\n          // ||\n          case tokenMatcher(operator, Or):\n            result = result || rhsResult;\n            break;\n\n          // <\n          case tokenMatcher(operator, LT):\n            result = result < rhsResult;\n            break;\n\n          // <=\n          case tokenMatcher(operator, LTE):\n            result = result <= rhsResult;\n            break;\n\n          // >\n          case tokenMatcher(operator, GT):\n            result = result > rhsResult;\n            break;\n\n          // >=\n          case tokenMatcher(operator, GTE):\n            result = result >= rhsResult;\n            break;\n        }\n      });\n    }\n\n    return result;\n  }\n\n  subExpression(ctx: any, context: ExpressionContext) {\n    let result: any;\n\n    switch (true) {\n      case !!ctx.value:\n        result = this.visit(ctx.value, context);\n        break;\n\n      case !!ctx.logicalGrouping:\n        result = this.visit(ctx.logicalGrouping, context);\n        break;\n\n      case !!ctx.array:\n        result = this.visit(ctx.array, context);\n        break;\n\n      case !!ctx.functionCall:\n        result = this.visit(ctx.functionCall, context);\n        break;\n\n      case !!ctx.contextAccess:\n        result = this.visit(ctx.contextAccess, context);\n        break;\n    }\n\n    if (!!ctx.Not) {\n      result = !result;\n    }\n\n    return result;\n  }\n\n  contextAccess(ctx: any, context: ExpressionContext) {\n    const contextName = Contexts.map((c) => (c.PATTERN as RegExp).source).find(\n      (c) => !!ctx[`Context${c}`]\n    );\n    if (!contextName) {\n      throw new Error(\"Unknown context: \" + contextName);\n    }\n\n    // Aggregate path\n    const p: PropertyPath = [];\n    if (!!ctx.contextMember) {\n      for (const cM of ctx.contextMember as any[]) {\n        this.visit(cM, { path: p, context });\n      }\n    }\n\n    const r = this.getContextValue(contextName, p, context);\n    return r;\n  }\n\n  protected getContextValue(\n    contextName: string,\n    path: PropertyPath,\n    context: ExpressionContext\n  ) {\n    const contextObject = context.contextProvider.get(contextName as any);\n    const result = iteratePath(path, contextObject);\n\n    return result || \"\";\n  }\n\n  contextMember(\n    ctx: any,\n    { path, context }: { path: PropertyPath; context: ExpressionContext }\n  ) {\n    switch (true) {\n      case !!ctx.contextDotMember:\n        return this.visit(ctx.contextDotMember, path);\n\n      case !!ctx.contextBoxMember:\n        return this.visit(ctx.contextBoxMember, { path, context });\n    }\n  }\n\n  contextDotMember(ctx: any, path: PropertyPath) {\n    const p = ctx.ContextMemberOrKeyword[0].image;\n    path.push(p);\n  }\n\n  contextBoxMember(\n    ctx: any,\n    { path, context }: { path: PropertyPath; context: ExpressionContext }\n  ) {\n    const p = this.visit(ctx.expression, context);\n    path.push(this._coerceValue(p, true));\n  }\n\n  logicalGrouping(ctx: any) {\n    return this.visit(ctx.expression);\n  }\n\n  array(ctx: any) {\n    const result: any[] = [];\n\n    if (ctx.subExpression) {\n      result.push(...ctx.subExpression.map((se) => this.visit(se)));\n    }\n\n    return result;\n  }\n\n  functionCall(ctx: any, context: ExpressionContext) {\n    const parameters = this.visit(ctx.functionParameters, context);\n\n    switch (true) {\n      case !!ctx.contains:\n        return Functions.contains(parameters[0], parameters[1]);\n\n      case !!ctx.startsWith:\n        return Functions.startsWith(parameters[0], parameters[1]);\n\n      case !!ctx.endsWith:\n        return Functions.endsWith(parameters[0], parameters[1]);\n\n      case !!ctx.join:\n        return Functions.join(parameters[0], parameters[1]);\n\n      case !!ctx.toJSON:\n        return Functions.toJSON(parameters[0]);\n\n      case !!ctx.fromJSON: {\n        const result = Functions.fromJSON(parameters[0]);\n\n        if (!!ctx.contextMember) {\n          const p: PropertyPath = [];\n          for (const cM of ctx.contextMember as any[]) {\n            this.visit(cM, { path: p, context });\n          }\n          return iteratePath(p, result);\n        }\n\n        return result;\n      }\n\n      case !!ctx.hashFiles:\n        return Functions.hashFiles(parameters);\n\n      case !!ctx.format:\n        return Functions.format(parameters[0], ...parameters.slice(1));\n\n      case !!ctx.always:\n        return Functions.always();\n\n      case !!ctx.failure:\n        return Functions.failure();\n\n      case !!ctx.success:\n        return Functions.success();\n\n      case !!ctx.cancelled:\n        return Functions.cancelled();\n    }\n\n    return undefined;\n  }\n\n  functionParameters(ctx: any, context: ExpressionContext) {\n    return (ctx.expression || []).map((p) => this.visit(p, context));\n  }\n\n  value(ctx: any) {\n    switch (true) {\n      case !!ctx.NumberLiteral:\n        return parseFloat(ctx.NumberLiteral[0].image);\n\n      case !!ctx.booleanValue:\n        return this.visit(ctx.booleanValue);\n\n      case !!ctx.Null:\n        return null;\n\n      case !!ctx.StringLiteral: {\n        const value: string = ctx.StringLiteral[0].image;\n        return this._removeQuotes(value);\n      }\n    }\n  }\n\n  booleanValue(ctx: any) {\n    switch (true) {\n      case !!ctx.True:\n        return true;\n\n      default:\n      case !!ctx.False:\n        return false;\n    }\n  }\n\n  private _coerceValue(\n    val: number | string | boolean | null,\n    keepString = false\n  ): number | string {\n    if (typeof val === \"number\") {\n      return val;\n    }\n\n    if (typeof val === \"string\") {\n      if (keepString) {\n        return val;\n      }\n\n      if (val === \"\") {\n        return 0;\n      }\n\n      return +val;\n    }\n\n    if (val === null) {\n      return 0;\n    }\n\n    if (val === true) {\n      return 1;\n    }\n\n    if (val === false) {\n      return 0;\n    }\n\n    return NaN;\n  }\n\n  private _removeQuotes(value: string): string {\n    return \"\" + value.substring(1, value.length - 1).replace(/''/g, \"'\");\n  }\n}\n\nexport const evaluator = new ExpressionEvaluator();\n","import { ILexingError, IRecognitionException } from \"chevrotain\";\nimport { expressionMarker } from \"./embedding\";\nimport { evaluator } from \"./evaluator\";\nimport { ExpressionLexer, parser } from \"./parser\";\nimport { ContextProvider } from \"./types\";\n\n// Work-around:\n// Export this to prevent name mangling, which breaks chevrotain's `functionName`\n// logic.\nexport { ExpressionParser } from \"./parser\";\n\nexport class ExpressionError extends Error {\n  constructor(\n    public lexErrors: ILexingError[],\n    public parseErrors: IRecognitionException[]\n  ) {\n    super(\n      `${lexErrors.map((x) => x.message).join()} ${parseErrors\n        .map((x) => x.message)\n        .join()}`\n    );\n  }\n}\n\nexport function parseExpression(expression: string) {\n  const lexResult = ExpressionLexer.tokenize(expression);\n  parser.input = lexResult.tokens;\n  const cst = parser.expression();\n  return cst;\n}\n\n/**\n * Evaluates a single expression with the given context\n *\n * @param expression Expression to evaluate, with or without ${{ }} marker\n * @param contextProvider Context provider for evaluation\n */\nexport function evaluateExpression(\n  expression: string,\n  contextProvider: ContextProvider\n) {\n  // This expects a single expression in the form of \"<expr>\" or \"${{ <expr> }}\". Remove the\n  // ${{ }} markers\n  expression = expression.replace(expressionMarker, (_, g) => g);\n\n  const lexResult = ExpressionLexer.tokenize(expression);\n\n  // setting a new input will RESET the parser instance's state.\n  parser.input = lexResult.tokens;\n\n  // any top level rule may be used as an entry point\n  const cst = parser.expression();\n\n  const result = evaluator.visit(cst, { contextProvider });\n\n  if (lexResult.errors.length > 0 || parser.errors.length > 0) {\n    throw new ExpressionError(lexResult.errors, parser.errors);\n  }\n\n  return result;\n}\n\n/**\n * Evaluates and replaces zero or more expressions in a string. Expressions must be surrounded with\n * ${{ <expr> }} and will be replaced with their evaluation result in the returned string.\n *\n * @param input String containing zero or more expression\n * @param contextProvider Context provider for evaluation\n */\nexport function replaceExpressions(\n  input: string,\n  contextProvider: ContextProvider\n): string {\n  return input.replace(expressionMarker, (_, g) => {\n    return evaluateExpression(g, contextProvider);\n  });\n}\n","import { Octokit } from \"@octokit/rest\";\nimport { YAMLException } from \"yaml-ast-parser\";\n\n//\n// Improved YAML AST types\n//\n\nexport enum Kind {\n  SCALAR = 0,\n  MAPPING = 1,\n  MAP = 2,\n  SEQ = 3,\n  ANCHOR_REF = 4,\n  INCLUDE_REF = 5,\n}\nexport interface YAMLDocument {\n  startPosition: number;\n  endPosition: number;\n  errors: YAMLException[];\n}\n\nexport interface YAMLNode extends YAMLDocument {\n  startPosition: number;\n  endPosition: number;\n  kind: Kind;\n  anchorId?: string;\n  valueObject?: any;\n  parent: YAMLNode;\n  errors: YAMLException[];\n  value?: any;\n  key?: any;\n  mappings?: any;\n}\n\nexport interface YAMLAnchorReference extends YAMLNode {\n  kind: Kind.ANCHOR_REF;\n\n  referencesAnchor: string;\n  value: YAMLNode;\n}\n\nexport interface YAMLScalar extends YAMLNode {\n  kind: Kind.SCALAR;\n\n  value: string;\n  doubleQuoted?: boolean;\n  singleQuoted?: boolean;\n  plainScalar?: boolean;\n  rawValue: string;\n}\n\nexport interface YAMLMapping extends YAMLNode {\n  kind: Kind.MAPPING;\n\n  key: YAMLScalar;\n  value: YAMLNode;\n}\n\nexport interface YAMLSequence extends YAMLNode {\n  kind: Kind.SEQ;\n\n  items: YAMLNode[];\n}\n\nexport interface YAMLMap extends YAMLNode {\n  kind: Kind.MAP;\n\n  mappings: YAMLMapping[];\n}\n\nexport type YNode = YAMLMap | YAMLMapping | YAMLSequence | YAMLScalar;\n\n//\n// Custom types\n//\n\nexport interface Context {\n  /** Octokit client to use for dynamic auto completion */\n  client: Octokit;\n\n  /** Repository owner */\n  owner: string;\n\n  /** Repository name */\n  repository: string;\n\n  /** Is the repository owned by an organization? */\n  ownerIsOrg?: boolean;\n\n  /**\n   * Are org features enabled, i.e., is the client authenticated for making org calls, which\n   * means does it have the admin:org scope\n   */\n  orgFeaturesEnabled?: boolean;\n\n  /**\n   * Dynamic auto-completion/validations are cached for a certain time to speed up successive\n   * operations.\n   *\n   * Setting this to a low number will greatly increase the number of API calls and duration\n   * parsing/validation/auto-completion will take.\n   *\n   * @default 10 * 60 * 1000 = 10 minutes\n   **/\n  timeToCacheResponsesInMS?: number;\n}\n\nexport type Position = [number, number];\n\nexport interface CompletionOption {\n  /** Auto complete value */\n  value: string;\n\n  /** Optional description for this completion option */\n  description?: string;\n}\n\nexport enum DiagnosticKind {\n  Error,\n  Warning,\n  Information,\n}\n\nexport interface Diagnostic {\n  /** Defaults to error */\n  kind?: DiagnosticKind;\n\n  message: string;\n\n  pos: Position;\n}\n\nexport interface Hover {\n  /** Description for the hover, might be formatted with markdown */\n  description: string;\n}\n","import { Kind, Position, YAMLNode, YNode } from \"../../types\";\n\nimport { PropertyPath } from \"../utils/path\";\n\nexport const DUMMY_KEY = \"dummy\";\n\nexport function inPos(position: Position, pos: number): boolean {\n  return position[0] <= pos && pos <= position[1];\n}\n\nexport function findNode(node: YAMLNode, pos: number): YAMLNode | null {\n  if (!inPos([node.startPosition, node.endPosition], pos)) {\n    return null;\n  }\n\n  const n: YNode = node as YNode;\n  switch (n.kind) {\n    case Kind.MAP: {\n      for (const mapping of n.mappings) {\n        if (inPos([mapping.startPosition, mapping.endPosition], pos)) {\n          return findNode(mapping, pos);\n        }\n      }\n\n      break;\n    }\n\n    case Kind.MAPPING: {\n      // If the position is within the value, return that, otherwise the mapping node\n      const r = node.value && findNode(n.value, pos);\n      if (r) {\n        return r;\n      }\n\n      // TODO: What to do here.. don't remember :)\n      if (node.key) {\n        if (\n          inPos([n.key.startPosition, n.key.endPosition], pos) ||\n          node.key.value === DUMMY_KEY\n        ) {\n          return node.parent;\n        }\n      }\n\n      break;\n    }\n\n    case Kind.SEQ: {\n      for (const item of n.items) {\n        if (typeof item !== \"object\") {\n          return n;\n        }\n\n        if (item === null) {\n          // New item like `- |` is inserted\n          return n;\n        }\n\n        if (inPos([item.startPosition, item.endPosition], pos)) {\n          const itemNode = findNode(item, pos);\n\n          // TODO: CS: Try to get rid of this logic\n          // if (itemNode.parent === n && itemNode.kind === Kind.SCALAR) {\n          //   // If the child is a plain value, return the sequence node\n          //   // return n;\n          // }\n\n          // Otherwise return the found node\n          return itemNode;\n        }\n      }\n\n      break;\n    }\n\n    case Kind.SCALAR: {\n      if (n.value && n.value === DUMMY_KEY) {\n        return n.parent;\n      }\n\n      return n;\n    }\n\n    default:\n      throw new Error(\"unknown\");\n  }\n\n  return node;\n}\n\nexport function getPathFromNode(node: YNode | null): PropertyPath {\n  // Build up node path\n  const nodePath: YNode[] = [];\n  let x = node;\n  while (x) {\n    // Add in reverse\n    nodePath.unshift(x);\n    x = x.parent as YNode;\n  }\n\n  const path: PropertyPath = [\"$\"];\n  while (nodePath.length) {\n    const x = nodePath.shift();\n\n    switch (x?.kind) {\n      case Kind.MAPPING:\n        if (x.key) {\n          path.push(x.key.value);\n        }\n\n        if (x.value) {\n          nodePath.unshift(x.value as YNode);\n        }\n        break;\n\n      case Kind.SEQ:\n        // Check next node to determine index\n        if (nodePath.length && x.items) {\n          const idx = x.items.indexOf(nodePath[0]);\n          if (idx !== -1) {\n            // Previous entry has to be a property. Note: this might be problematic with nested sequences,\n            // but that's not currently supported.\n            const propertyName: string = path[path.length - 1] as string;\n            path[path.length - 1] = [propertyName, idx];\n          }\n        }\n        break;\n    }\n  }\n\n  return path;\n}\n","import { Uses } from \"../workflow\";\n\nexport function parseUses(input: string): Uses {\n  if (input.indexOf(\"@\") !== -1) {\n    // Remote uses\n    const [x, ref] = input.split(\"@\");\n    const [_, owner, repository, subdirectory] = x.match(\n      /([^\\/]*)\\/([^\\/]*)\\/?(.*)?/\n    )!;\n\n    return {\n      type: \"remote\",\n      ref,\n      owner,\n      repository,\n      subdirectory,\n    };\n  } else if (input.indexOf(\"docker://\") !== -1) {\n    // TODO: Parse docker uses\n    return {\n      type: \"docker\",\n    };\n  } else {\n    // Local\n    return {\n      type: \"local\",\n    };\n  }\n}\n","import { Expression, Job, MatrixInvocations, Workflow } from \"../workflow\";\n\nimport { DUMMY_KEY } from \"../parser/ast\";\nimport { parseUses } from \"../workflowschema/uses\";\n\nfunction toArray(input: string | string[]): string[] {\n  if (Array.isArray(input)) {\n    return input;\n  }\n\n  return [input];\n}\n\nexport function normalizeWorkflow(filename: string, workflow: Workflow) {\n  // Name\n  workflow.name = workflow.name || filename;\n\n  // On\n  if (typeof workflow.on === \"string\") {\n    workflow.on = {\n      [workflow.on]: {},\n    };\n  } else if (Array.isArray(workflow.on)) {\n    workflow.on = workflow.on.reduce((o, x) => {\n      o[x] = {};\n      return o;\n    }, {});\n  }\n\n  // Jobs\n  if (!workflow.jobs) {\n    workflow.jobs = {};\n  }\n\n  for (const jobId of Object.keys(workflow.jobs).filter(\n    (x) => x !== DUMMY_KEY\n  )) {\n    normalizeJob(workflow.jobs[jobId]);\n  }\n}\n\nfunction normalizeJob(job: Job) {\n  // Strategy\n  if (job.strategy?.matrix) {\n    // TODO: Should switch to build up the workflow using the AST instead of parsing and transforming in place\n    job.strategy.matrix = normalizeMatrix(job.strategy.matrix as any);\n  }\n\n  // Steps\n  if (!Array.isArray(job.steps)) {\n    job.steps = [];\n  }\n\n  job.steps = job.steps.filter((x) => typeof x === \"object\");\n\n  for (const step of job.steps) {\n    // Uses\n    if (step && \"uses\" in step && typeof step.uses === \"string\") {\n      step.uses = parseUses(step.uses);\n    }\n  }\n\n  // Other properties\n  job.needs = job.needs && toArray(job.needs);\n  job[\"timeout-minutes\"] = job[\"timeout-minutes\"] || 360;\n}\n\nexport function normalizeMatrix(\n  matrix:\n    | {\n        // @ts-ignore\n        include?: Object[];\n        // @ts-ignore\n        exclude?: Object[];\n\n        [key: string]: (string | number | boolean)[];\n      }\n    | Expression\n): MatrixInvocations | Expression {\n  if (typeof matrix === \"string\") {\n    // Expression\n    return matrix;\n  }\n\n  const explicitMatrixKeys = Object.keys(matrix).filter(\n    (x) => x !== \"include\" && x !== \"exclude\"\n  );\n\n  const matrixValues: {\n    [inputKey: string]: (string | number | boolean)[];\n  } = {};\n  for (const explicitMatrixKey of explicitMatrixKeys) {\n    matrixValues[explicitMatrixKey] = matrix[explicitMatrixKey];\n  }\n\n  let invocations = crossProduct(matrixValues);\n\n  // Process excludes, this has to happen before the includes (see\n  // https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions#example-excluding-configurations-from-a-matrix)\n  if (matrix[\"exclude\"]) {\n    // Iterate over all values, remove matching pairs\n    for (const toExclude of matrix.exclude) {\n      invocations = invocations.filter((x) => !deepEqual(x, toExclude));\n    }\n  }\n\n  if (matrix[\"include\"]) {\n    for (const toInclude of matrix.include) {\n      // Find an existing entry to extend\n      const idx = invocations.findIndex((x) => leftEqual(x, toInclude));\n      if (idx !== -1) {\n        invocations.splice(idx, 1, toInclude as any);\n      } else {\n        invocations.push(toInclude as any);\n      }\n    }\n  }\n\n  return invocations;\n}\n\nfunction leftEqual(a: Object, b: Object) {\n  const keysA = Object.keys(a);\n\n  return keysA.every((keyA) => a[keyA] === b[keyA]);\n}\n\nfunction deepEqual(a: Object, b: Object) {\n  const keysA = Object.keys(a);\n  const keysB = Object.keys(b);\n\n  return (\n    keysB.length === keysA.length && keysA.every((keyA) => a[keyA] === b[keyA])\n  );\n}\n\nexport function crossProduct(inputs: {\n  [inputKey: string]: (string | number | boolean)[];\n}): { [key: string]: string | number | boolean }[] {\n  let result: { [key: string]: string | number | boolean }[] = [];\n\n  for (const inputKey of Object.keys(inputs)) {\n    if (result.length === 0) {\n      // Add first iteration\n      result.push(\n        ...inputs[inputKey].map((x) => ({\n          [inputKey]: x,\n        }))\n      );\n    } else {\n      let newResult: { [key: string]: string | number | boolean }[] = [];\n\n      // Add to existing values\n      for (const inputValue of inputs[inputKey]) {\n        for (const r of result) {\n          newResult.push({\n            ...r,\n            [inputKey]: inputValue,\n          });\n        }\n      }\n\n      result = newResult;\n    }\n  }\n\n  return result;\n}\n","export interface ContextProvider {\n  get(\n    context:\n      | \"github\"\n      | \"env\"\n      | \"job\"\n      | \"steps\"\n      | \"runner\"\n      | \"secrets\"\n      | \"strategy\"\n      | \"matrix\"\n      | \"needs\"\n  ): Object;\n}\n\nexport const DynamicContext = {};\n","import { ContextProvider, DynamicContext } from \"./types\";\nimport { Diagnostic, Position } from \"../../types\";\nimport { ExpressionContext, ExpressionEvaluator } from \"./evaluator\";\nimport { ExpressionLexer, parser } from \"./parser\";\nimport { PropertyPath, iteratePath } from \"../utils/path\";\nimport { iterateExpressions, removeExpressionMarker } from \"./embedding\";\n\nimport { Undetermined } from \"./functions\";\n\nfunction iterateContextPath(path: PropertyPath, context: Object): any {\n  let dynamicNode = false;\n\n  const result = iteratePath(path, context, (x) => {\n    if (x === DynamicContext) {\n      dynamicNode = true;\n    }\n  });\n\n  if (dynamicNode) {\n    // We have encountered at least one DynamicContext while iterating. Dynamic contexts\n    // are built up at runtime, and we cannot reliably reason about those.\n    return Undetermined;\n  }\n\n  return result;\n}\n\nclass ExpressionValidator extends ExpressionEvaluator {\n  constructor(\n    private contextProvider: ContextProvider,\n    private errors: Diagnostic[],\n    private pos: Position\n  ) {\n    super();\n  }\n\n  protected getContextValue(contextName: string, path: PropertyPath) {\n    const ctx = this.contextProvider.get(contextName as any);\n\n    const value = ctx && iterateContextPath(path, ctx);\n    if (!ctx || (value !== Undetermined && value === undefined)) {\n      this.errors.push({\n        message: `Unknown context access: '${contextName}.${path.join(\".\")}'`,\n        pos: this.pos,\n      });\n    }\n\n    return value;\n  }\n}\n\nexport function validateExpression(\n  input: string,\n  posOffset: number,\n  diagnostics: Diagnostic[],\n  contextProvider: ContextProvider\n) {\n  const expressionPosition: Position = [posOffset, posOffset + input.length];\n\n  input = removeExpressionMarker(input);\n\n  // Check for parser errors\n  const lexResult = ExpressionLexer.tokenize(input);\n  parser.input = lexResult.tokens;\n  if (lexResult.errors.length > 0) {\n    diagnostics.push({\n      message: \"Invalid expression\",\n      pos: expressionPosition,\n    });\n\n    return;\n  }\n\n  const cst = parser.expression();\n  if (parser.errors.length > 0) {\n    diagnostics.push({\n      message: \"Invalid expression\",\n      pos: expressionPosition,\n    });\n\n    // console.log(JSON.stringify(parser.errors));\n\n    return;\n  }\n\n  try {\n    const result = new ExpressionValidator(\n      contextProvider,\n      diagnostics,\n      expressionPosition\n    ).visit(cst, {} as ExpressionContext);\n\n    return result;\n  } catch (e) {\n    console.error(e);\n\n    diagnostics.push({\n      message: \"Error evaluating expression\",\n      pos: expressionPosition,\n    });\n  }\n}\n\nexport function validateExpressions(\n  input: string,\n  posOffset: number,\n  errors: Diagnostic[],\n  contextProvider: ContextProvider\n) {\n  iterateExpressions(input, (expr, pos) => {\n    validateExpression(expr, posOffset + pos, errors, contextProvider);\n  });\n}\n","import { PropertyPath } from \"../utils/path\";\nimport { Workflow } from \"../workflow\";\n\nexport type NodeDescMap = { [key: string]: NodeDesc };\n\ntype Desc = {\n  /** Description for this node, can contain markdown */\n  description?: string;\n\n  /**\n   * Custom value provider, used for auto-complete and validation\n   *\n   * @param desc Description for node to provide value for\n   * @param workflow Workflow if it could be parsed\n   * @param path Path in the workflow\n   */\n  customValueProvider?: CustomValueProvider;\n};\n\ntype OneOfNodeDesc = {\n  type: \"oneOf\";\n\n  oneOf: NodeDesc[];\n} & Desc;\n\nexport type MapNodeDesc = {\n  type: \"map\";\n\n  /**\n   * Map of key to Node or Node array.\n   */\n  keys?: NodeDescMap;\n\n  /**\n   * Specify a template to validate unknown keys against\n   */\n  itemDesc?: NodeDesc;\n\n  /**\n   * Should unknown keys be allowed\n   */\n  allowUnknownKeys?: boolean;\n\n  /**\n   * Required keys for the map\n   */\n  required?: string[];\n} & Desc;\n\ntype SequenceNodeDesc = {\n  type: \"sequence\";\n\n  itemDesc?: NodeDesc;\n} & Desc;\n\nexport type ValueDesc = {\n  value: string;\n  description?: string;\n} & Desc;\n\nexport type ValueNodeDesc = {\n  type: \"value\";\n\n  /** Allowed values */\n  allowedValues?: ValueDesc[];\n\n  /** If the node allows omitting ${{ }} to enter an expression */\n  isExpression?: boolean;\n\n  /**\n   * If a value can be set using an expression, this will disable checking\n   * against `allowedValues` when set\n   */\n  supportsExpression?: boolean;\n} & Desc;\n\nexport type NodeDesc =\n  | ValueNodeDesc\n  | SequenceNodeDesc\n  | MapNodeDesc\n  | OneOfNodeDesc;\n\nexport enum CustomValueValidation {\n  /** Default, no special handling */\n  None = 0,\n\n  /**\n   * Value/key must be provided\n   *\n   * This is mostly used for requiring certain keys to be provided\n   **/\n  Required = 1,\n}\n\nexport interface CustomValue {\n  value: string;\n\n  description?: string;\n\n  validation?: CustomValueValidation;\n}\n\nexport type CustomValueProvider = (\n  desc: NodeDesc,\n  workflow: Workflow | undefined,\n  path: PropertyPath\n) => Promise<CustomValue[] | undefined>;\n","import {\n  Kind,\n  YamlMap,\n  YAMLMapping,\n  YAMLNode,\n  YAMLScalar,\n} from \"yaml-ast-parser\";\nimport { Diagnostic, DiagnosticKind, Position, YNode } from \"../../types\";\nimport { evaluateExpression, replaceExpressions } from \"../expressions\";\nimport {\n  containsExpression,\n  iterateExpressions,\n} from \"../expressions/embedding\";\nimport { ContextProvider } from \"../expressions/types\";\nimport { validateExpression } from \"../expressions/validator\";\nimport { Workflow } from \"../workflow\";\nimport { getPathFromNode } from \"./ast\";\nimport { ContextProviderFactory } from \"./complete\";\nimport { CustomValue, CustomValueValidation, NodeDesc } from \"./schema\";\n\nfunction kindToString(kind: Kind): string {\n  switch (kind) {\n    case Kind.SCALAR:\n      return \"value\";\n\n    case Kind.MAPPING:\n      return \"mapping\";\n\n    case Kind.MAP:\n      return \"map\";\n\n    case Kind.SEQ:\n      return \"sequence\";\n\n    default:\n      throw new Error(\"Unexpected node kind\");\n  }\n}\n\nfunction validateExpressions(\n  input: string,\n  posOffset: number,\n  errors: Diagnostic[],\n  contextProvider: ContextProvider\n) {\n  iterateExpressions(input, (expr, pos) => {\n    validateExpression(expr, posOffset + pos, errors, contextProvider);\n  });\n}\n\nasync function validateNode(\n  node: YAMLNode,\n  nodeDesc: NodeDesc,\n  nodeToDesc: Map<YAMLNode, NodeDesc>,\n  workflow: Workflow | undefined,\n  contextProviderFactory: ContextProviderFactory,\n  diagnostics: Diagnostic[]\n): Promise<boolean> {\n  if (!node) {\n    return true;\n  }\n\n  const n = node as YNode;\n\n  const reportTypeMismatch = (expectedType: string, actualKind: Kind) => {\n    diagnostics.push({\n      pos: [n.startPosition, n.endPosition],\n      message: `Expected ${expectedType}, found ${kindToString(actualKind)}`,\n    });\n  };\n\n  switch (nodeDesc.type) {\n    case \"value\": {\n      if (n.kind !== Kind.SCALAR) {\n        reportTypeMismatch(\"value\", n.kind);\n      }\n\n      const scalarNode = node as YAMLScalar;\n\n      // Store for later lookup\n      nodeToDesc.set(scalarNode, nodeDesc);\n\n      let input = scalarNode.value;\n\n      if (nodeDesc.isExpression || containsExpression(input)) {\n        const path = getPathFromNode(n);\n\n        const contextProvider = await contextProviderFactory.get(\n          workflow,\n          path\n        );\n\n        // Validate scalar value as expression if it looks like one, or if we always expect one\n        // here.\n        validateExpressions(\n          // Use raw value here to match offsets\n          scalarNode.rawValue,\n          n.startPosition,\n          diagnostics,\n          contextProvider\n        );\n\n        if (nodeDesc.supportsExpression) {\n          input = replaceExpressions(scalarNode.rawValue, contextProvider);\n        }\n      }\n\n      // Value is set using an expression, we cannot check against allowed values\n      // In the future we might try to resolve this but for now don't do any additional checking\n      if (\n        nodeDesc.allowedValues &&\n        !nodeDesc.allowedValues.find((x) => x.value === input)\n      ) {\n        diagnostics.push({\n          pos: [scalarNode.startPosition, scalarNode.endPosition],\n          message: `'${input}' is not in the list of allowed values`,\n        });\n      } else if (nodeDesc.customValueProvider) {\n        let customValues: CustomValue[] | undefined;\n\n        try {\n          customValues = await nodeDesc.customValueProvider(\n            nodeDesc,\n            workflow,\n            getPathFromNode(n)\n          );\n        } catch (e) {\n          diagnostics.push({\n            kind: DiagnosticKind.Warning,\n            pos: [scalarNode.startPosition, scalarNode.endPosition],\n            message: `Could not retrieve values: ${e?.message}`,\n          });\n        }\n\n        if (customValues && !customValues?.find((x) => x.value === input)) {\n          diagnostics.push({\n            pos: [scalarNode.startPosition, scalarNode.endPosition],\n            message: `'${input}' is not in the list of allowed values`,\n          });\n        }\n      }\n\n      break;\n    }\n\n    case \"map\": {\n      if (n.kind !== Kind.MAP) {\n        if (n.kind === Kind.SCALAR) {\n          diagnostics.push({\n            pos: [n.startPosition, n.endPosition],\n            message: `Unknown key '${n.value}'`,\n          });\n          return false;\n        }\n\n        reportTypeMismatch(\"map\", n.kind);\n      }\n\n      const mapNode = node as YamlMap;\n      nodeToDesc.set(node, nodeDesc);\n\n      let customValues: CustomValue[] | undefined;\n      if (nodeDesc.customValueProvider) {\n        try {\n          customValues = await nodeDesc.customValueProvider(\n            nodeDesc,\n            workflow,\n            getPathFromNode(n)\n          );\n        } catch (e) {\n          diagnostics.push({\n            kind: DiagnosticKind.Warning,\n            pos: [mapNode.startPosition, mapNode.endPosition],\n            message: `Could not retrieve values: ${e?.message}`,\n          });\n        }\n      }\n\n      const seenKeys = new Map<string, YAMLMapping>();\n\n      for (const mapping of mapNode.mappings) {\n        const key = mapping.key.value;\n        seenKeys.set(key, mapping);\n\n        // Check if we know more about this key\n        const mappingDesc = nodeDesc.keys && nodeDesc.keys[key];\n        if (mappingDesc) {\n          // Validate each mapping\n\n          // Add mapping desc for later lookup (e.g., to complete keys)\n          nodeToDesc.set(mapping, mappingDesc);\n          await validateNode(\n            mapping.value,\n            mappingDesc,\n            nodeToDesc,\n            workflow,\n            contextProviderFactory,\n            diagnostics\n          );\n        } else if (nodeDesc.itemDesc) {\n          await validateNode(\n            mapping.value,\n            nodeDesc.itemDesc,\n            nodeToDesc,\n            workflow,\n            contextProviderFactory,\n            diagnostics\n          );\n        }\n      }\n\n      // Check required keys\n      if (nodeDesc.required || customValues) {\n        const requiredKeys = [\n          ...(nodeDesc.required || []),\n          ...(customValues || [])\n            .filter((x) => x.validation === CustomValueValidation.Required)\n            .map((x) => x.value),\n        ];\n\n        for (const missingKey of requiredKeys.filter(\n          (key) => !seenKeys.has(key)\n        )) {\n          let pos: Position = [mapNode.startPosition, mapNode.endPosition];\n          if (mapNode.parent && mapNode.parent.key) {\n            pos = [\n              mapNode.parent.key.startPosition,\n              mapNode.parent.key.endPosition,\n            ];\n          }\n\n          diagnostics.push({\n            pos,\n            message: `Missing required key '${missingKey}'`,\n          });\n        }\n      }\n\n      if (!nodeDesc.allowUnknownKeys && (nodeDesc.keys || customValues)) {\n        // Calculate list of allowed keys from schema and dynamic values\n        const allowedKeys = new Set<string>([\n          ...((nodeDesc.keys && Object.keys(nodeDesc.keys)) || []),\n          ...(customValues || []).map((x) => x.value),\n        ]);\n\n        // Compare allowed and seen keys\n        const unknownKeys = Array.from(seenKeys).filter(\n          ([key]) => !allowedKeys.has(key)\n        );\n        for (const [unknownKey, mappingNode] of unknownKeys) {\n          diagnostics.push({\n            pos: [mappingNode.key.startPosition, mappingNode.key.endPosition],\n            message: `Key '${unknownKey}' is not allowed`,\n          });\n        }\n      }\n\n      break;\n    }\n\n    case \"sequence\": {\n      if (n.kind !== Kind.SEQ) {\n        reportTypeMismatch(\"sequence\", n.kind);\n      } else {\n        nodeToDesc.set(node, nodeDesc);\n\n        if (nodeDesc.itemDesc) {\n          for (const item of n.items) {\n            // Record the itemdesc as the desired desc for the item. This might fail in the validateNode call,\n            // but is required for auto-complete (e.g., type doesn't match yet, but we still want to be able to\n            // suggest values)\n            nodeToDesc.set(item, nodeDesc.itemDesc);\n\n            await validateNode(\n              item,\n              nodeDesc.itemDesc,\n              nodeToDesc,\n              workflow,\n              contextProviderFactory,\n              diagnostics\n            );\n          }\n        }\n      }\n\n      break;\n    }\n\n    case \"oneOf\": {\n      let foundMatchingNode = false;\n\n      for (const nDesc of nodeDesc.oneOf) {\n        switch (nDesc.type) {\n          case \"value\":\n            if (node.kind === Kind.SCALAR) {\n              await validateNode(\n                node,\n                nDesc,\n                nodeToDesc,\n                workflow,\n                contextProviderFactory,\n                diagnostics\n              );\n              foundMatchingNode = true;\n            }\n            break;\n\n          case \"map\":\n            if (node.kind === Kind.MAP) {\n              await validateNode(\n                node,\n                nDesc,\n                nodeToDesc,\n                workflow,\n                contextProviderFactory,\n                diagnostics\n              );\n              foundMatchingNode = true;\n            }\n            break;\n\n          case \"sequence\":\n            if (node.kind === Kind.SEQ) {\n              await validateNode(\n                node,\n                nDesc,\n                nodeToDesc,\n                workflow,\n                contextProviderFactory,\n                diagnostics\n              );\n              foundMatchingNode = true;\n            }\n            break;\n        }\n      }\n\n      if (!foundMatchingNode) {\n        diagnostics.push({\n          pos: [node.startPosition, node.endPosition],\n          message: `Did not expect '${kindToString(n.kind)}'`,\n        });\n      }\n    }\n  }\n\n  return true;\n}\n\nexport interface ValidationResult {\n  errors: Diagnostic[];\n\n  nodeToDesc: Map<YAMLNode, NodeDesc>;\n}\n\nexport async function validate(\n  root: YAMLNode,\n  schema: NodeDesc,\n  workflow: Workflow | undefined,\n  contextProviderFactory: ContextProviderFactory\n): Promise<ValidationResult> {\n  const diagnostics: Diagnostic[] = [];\n  const nodeToDesc = new Map<YAMLNode, NodeDesc>();\n  // nodeToDesc.set(null, schema);\n\n  await validateNode(\n    root,\n    schema,\n    nodeToDesc,\n    workflow,\n    contextProviderFactory,\n    diagnostics\n  );\n\n  return {\n    errors: diagnostics.map((x) => ({\n      ...x,\n      kind: x.kind || DiagnosticKind.Error,\n    })),\n    nodeToDesc,\n  };\n}\n","import { Diagnostic, DiagnosticKind, Position } from \"../../types\";\nimport { YAMLNode, safeLoad } from \"yaml-ast-parser\";\n\nimport { ContextProviderFactory } from \"./complete\";\nimport { NodeDesc } from \"./schema\";\nimport { Workflow } from \"../workflow\";\nimport { load as jsYamlLoad } from \"js-yaml\";\nimport { normalizeWorkflow } from \"../workflow/normalize\";\nimport { validate } from \"./validator\";\n\nexport interface WorkflowDocument {\n  /** Normalized workflow */\n  workflow?: Workflow;\n\n  /** Errors and warnings found during parsing */\n  diagnostics: Diagnostic[];\n\n  /** Workflow AST */\n  workflowST: YAMLNode;\n\n  /** Mapping of AST nodes to mapped schema descriptions */\n  nodeToDesc: Map<YAMLNode, NodeDesc>;\n}\n\nexport async function parse(\n  filename: string,\n  input: string,\n  schema: NodeDesc,\n  contextProviderFactory: ContextProviderFactory\n): Promise<WorkflowDocument> {\n  const diagnostics: Diagnostic[] = [];\n\n  // First, parse workflow using js-yaml\n  let workflow: Workflow | undefined;\n\n  try {\n    workflow = jsYamlLoad(input);\n  } catch {\n    // Ignore error here, will be reported below\n  }\n\n  // Normalize the resulting JSON object, e.g., make sure options that can be specified in\n  // multiple ways in the YAML (scalar/sequence/map) are always represented in the same way.\n  if (typeof workflow === \"object\") {\n    normalizeWorkflow(filename, workflow);\n  } else {\n    // Workflow couldn't be parsed correctly, set to undefined since we cannot reason about it anyway\n    workflow = undefined;\n  }\n\n  // Second, parse again using yaml-ast-parser. The resulting AST is used for validation, auto-completion\n  // and other evaluations.\n  //\n  // Long term it's obviously wasteful to parse the input twice and the workflow JSON should be derived\n  // from the AST, but for now this is the easiest option.\n  const yamlRoot = safeLoad(input);\n  if (yamlRoot) {\n    if (yamlRoot.errors.length > 0) {\n      diagnostics.push(\n        ...yamlRoot.errors.map((e) => ({\n          kind: e.isWarning ? DiagnosticKind.Warning : DiagnosticKind.Error,\n          message: e.reason,\n          pos: [e.mark.position, e.mark.position + 1] as Position,\n        }))\n      );\n    }\n  } else {\n    diagnostics.push({\n      message: \"Could not parse input\",\n      pos: [0, input?.length || 0],\n      kind: DiagnosticKind.Error,\n    });\n  }\n\n  const validationResult = await validate(\n    yamlRoot,\n    schema,\n    workflow,\n    contextProviderFactory\n  );\n  diagnostics.push(...validationResult.errors);\n\n  return {\n    workflow,\n    workflowST: yamlRoot,\n    nodeToDesc: validationResult.nodeToDesc,\n    diagnostics,\n  };\n}\n","import { CompletionOption, Kind, YNode } from \"../../types\";\nimport { CustomValue, MapNodeDesc, NodeDesc } from \"./schema\";\nimport { DUMMY_KEY, findNode, getPathFromNode } from \"./ast\";\nimport { WorkflowDocument, parse } from \"./parser\";\nimport { completeExpression, inExpression } from \"../expressions/completion\";\nimport { expressionMarker, iterateExpressions } from \"../expressions/embedding\";\n\nimport { ContextProvider } from \"../expressions/types\";\nimport { PropertyPath } from \"../utils/path\";\nimport { Workflow } from \"../workflow\";\nimport { YAMLNode } from \"yaml-ast-parser\";\n\nexport interface ContextProviderFactory {\n  get(\n    workflow: Workflow | undefined,\n    path: PropertyPath\n  ): Promise<ContextProvider>;\n}\n\nfunction filterAndSortCompletionOptions(\n  partialInput: string,\n  options: CompletionOption[],\n  existingValues?: Set<string>\n) {\n  options = options\n    .filter((x) => !existingValues || !existingValues.has(x.value))\n    .filter((x) => !partialInput || x.value.startsWith(partialInput));\n  options.sort((a, b) => a.value.localeCompare(b.value));\n  return options;\n}\n\nasync function completeMapKeys(\n  doc: WorkflowDocument,\n  node: YNode | null,\n  mapDesc: MapNodeDesc,\n  line: string,\n  partialInput: string\n): Promise<CompletionOption[]> {\n  const existingKeys = new Set<string>(\n    node?.mappings?.filter((x) => !!x.key).map((x) => x.key.value) || []\n  );\n\n  let options: CompletionOption[] = [];\n\n  if (mapDesc.customValueProvider) {\n    try {\n      const customValues = await mapDesc.customValueProvider(\n        mapDesc,\n        doc.workflow,\n        getPathFromNode(node)\n      );\n      if (customValues) {\n        options.push(...customValues);\n      }\n    } catch (e) {\n      // Log, but ignore custom values in case of error\n      console.error(e);\n    }\n  }\n\n  if (mapDesc.keys) {\n    options.push(\n      ...Object.keys(mapDesc.keys).map((key) => ({\n        value: key,\n        description: mapDesc.keys![key].description,\n      }))\n    );\n  }\n\n  return filterAndSortCompletionOptions(partialInput, options, existingKeys);\n}\n\nasync function doComplete(\n  node: YNode,\n  desc: NodeDesc,\n  input: string,\n  partialInput: string,\n  pos: number,\n  doc: WorkflowDocument,\n  contextProviderFactory: ContextProviderFactory\n): Promise<CompletionOption[]> {\n  if (!node) {\n    console.error(desc);\n    throw new Error(\"no node\");\n  }\n\n  // console.log(desc);\n\n  switch (desc.type) {\n    case \"value\": {\n      let searchInput = node.value || \"\";\n      searchInput = searchInput !== DUMMY_KEY ? searchInput : \"\";\n\n      const parent = node.parent as YNode;\n\n      // Are we in a sequence?\n      let existingItems: YAMLNode[] = [];\n      if (parent.kind === Kind.SEQ) {\n        existingItems = parent.items;\n      } else if (node.kind === Kind.SEQ) {\n        // Is the current node a sequence? Could happen if we are trying to auto-complete and have an empty input\n        existingItems = node.items;\n      }\n      const existingValues = new Set<string>(\n        existingItems\n          .filter((x) => !!x && x.kind === Kind.SCALAR)\n          .map((x) => x.value)\n      );\n\n      // Does the value node has auto-complete information?\n      if (desc.customValueProvider) {\n        let customValues: CustomValue[] | undefined;\n\n        try {\n          customValues = await desc.customValueProvider(\n            desc,\n            doc.workflow,\n            getPathFromNode(node)\n          );\n        } catch (e) {\n          // Log, but ignore custom values in case of error\n          console.error(e);\n        }\n\n        return filterAndSortCompletionOptions(\n          searchInput,\n          customValues || [],\n          new Set<string>(existingValues)\n        );\n      } else if (desc.allowedValues) {\n        return filterAndSortCompletionOptions(\n          searchInput,\n          desc.allowedValues,\n          existingValues\n        );\n      } else if (\n        desc.isExpression ||\n        inExpression(node.value, pos - node.startPosition)\n      ) {\n        return expressionComplete(\n          node,\n          pos,\n          getPathFromNode(node),\n          doc.workflow!,\n          contextProviderFactory,\n          desc.isExpression\n        );\n      }\n\n      break;\n    }\n\n    case \"sequence\": {\n      if (desc.itemDesc) {\n        return doComplete(\n          node,\n          desc.itemDesc,\n          input,\n          partialInput,\n          pos,\n          doc,\n          contextProviderFactory\n        );\n      }\n\n      break;\n    }\n\n    case \"map\": {\n      // Check what to complete\n      if (node.kind === Kind.MAP) {\n        // We should be in a mapping, try to find it\n        const mapping = findNode(doc.workflowST, pos) as YNode;\n        if (mapping.kind === Kind.MAPPING) {\n          const mapDesc = doc.nodeToDesc.get(mapping.parent) as MapNodeDesc;\n          if (mapDesc.type !== \"map\") {\n            throw new Error(\"Could not find map node\");\n          }\n\n          const key = mapping.key.value;\n          return doComplete(\n            mapping,\n            mapDesc.keys![key],\n            input,\n            partialInput,\n            pos,\n            doc,\n            contextProviderFactory\n          );\n        }\n      }\n\n      return completeMapKeys(doc, node, desc, input, partialInput);\n    }\n\n    case \"oneOf\": {\n      const validTypes = getValidOneOfTypes(node, pos, input);\n\n      const result: CompletionOption[] = [];\n\n      for (const one of desc.oneOf.filter((one) => validTypes.has(one.type))) {\n        const c = await doComplete(\n          node,\n          one,\n          input,\n          partialInput,\n          pos,\n          doc,\n          contextProviderFactory\n        );\n        result.push(...c);\n      }\n\n      return result;\n    }\n  }\n\n  throw new Error(`Unknown node desc ${desc.type}`);\n}\n\nfunction getValidOneOfTypes(node: YNode, pos: number, input: string) {\n  const validTypes = new Set<NodeDesc[\"type\"]>();\n\n  switch (node.kind) {\n    case Kind.SCALAR: {\n      validTypes.add(\"value\");\n      break;\n    }\n\n    // case Kind.MAP:\n    //   break;\n\n    case Kind.MAPPING: {\n      const [line] = getCurrentLine(pos, input);\n      if (line.indexOf(\":\") >= 0) {\n        validTypes.add(\"value\");\n      }\n      break;\n    }\n\n    case Kind.SEQ: {\n      validTypes.add(\"sequence\");\n      break;\n    }\n  }\n\n  return validTypes;\n}\n\nfunction getCurrentLine(\n  pos: number,\n  input: string,\n  trim = true\n): [string, number] {\n  let s = pos;\n  while (s > 0 && input[s] !== \"\\n\") {\n    --s;\n\n    if (input[s] === \"\\n\") {\n      ++s;\n      break;\n    }\n  }\n\n  const line = input.substring(s, pos + 1);\n  return [trim ? line.trim() : line, pos - s];\n}\n\nasync function expressionComplete(\n  node: YNode,\n  pos: number,\n  path: PropertyPath,\n  workflow: Workflow,\n  contextProviderFactory: ContextProviderFactory,\n  isExpression = false\n): Promise<CompletionOption[]> {\n  const input = `${node.value}`;\n  const inputPos = pos - node.startPosition;\n\n  // Determine expression\n  let expression = input;\n  let expressionPos = inputPos;\n  if (!isExpression) {\n    let expressionFound = false;\n    iterateExpressions(input, (exp, start, length) => {\n      if (start <= inputPos && inputPos <= start + length) {\n        expressionFound = true;\n        expression = exp;\n        expressionPos = inputPos - start;\n      }\n    });\n\n    // Check for partial expression\n    if (!expressionFound) {\n      const startPos = input.indexOf(\"${{\");\n      if (startPos === -1) {\n        return [];\n      }\n\n      expression = input.substr(startPos + 3);\n      expressionPos = inputPos - startPos - 3;\n    }\n  }\n\n  expression = expression.replace(expressionMarker, \"$1\");\n\n  const contextProvider = await contextProviderFactory.get(workflow, path);\n  return completeExpression(expression, expressionPos, contextProvider);\n}\n\nfunction _transform(input: string, pos: number): [string, number, string] {\n  // TODO: Optimize this...\n  const lines = input.split(\"\\n\");\n  const lineNo = input\n    .substring(0, pos)\n    .split(\"\")\n    .filter((x) => x === \"\\n\").length;\n  const linePos =\n    pos - lines.slice(0, lineNo).reduce((p, l) => p + l.length + 1, 0);\n  const line = lines[lineNo];\n\n  let partialInput = line.trim();\n  // Special case for Actions, if this line contains an expression marker, do _not_ transform. This is\n  // an ugly fix for auto-completion in multi-line YAML strings. At this point in the process, we cannot\n  // determine if a line is in such a multi-line string.\n  if (partialInput.indexOf(\"${{\") === -1) {\n    const colon = line.indexOf(\":\");\n    if (colon === -1) {\n      const trimmedLine = line.trim();\n      if (trimmedLine === \"\" || trimmedLine === \"-\") {\n        // Node in sequence or empty line\n        let spacer = \"\";\n        if (trimmedLine === \"-\" && !line.endsWith(\" \")) {\n          spacer = \" \";\n          pos++;\n        }\n\n        lines[lineNo] =\n          line.substring(0, linePos) +\n          spacer +\n          DUMMY_KEY +\n          (trimmedLine === \"-\" ? \"\" : \":\") +\n          line.substring(linePos);\n\n        // Adjust pos by one to prevent a sequence node being marked as active\n        pos++;\n      } else if (!trimmedLine.startsWith(\"-\")) {\n        // Add `:` to end of line\n        lines[lineNo] = line + \":\";\n      }\n\n      if (trimmedLine.startsWith(\"-\")) {\n        partialInput = trimmedLine\n          .substring(trimmedLine.indexOf(\"-\") + 1)\n          .trim();\n      }\n    } else {\n      partialInput = (pos > colon\n        ? line.substring(colon + 1)\n        : line.substring(0, colon)\n      ).trim();\n      pos = pos - 1;\n    }\n  }\n  // console.log(`partialInput '${partialInput}'`);\n  return [lines.join(\"\\n\"), pos, partialInput];\n}\n\nexport async function complete(\n  filename: string,\n  input: string,\n  pos: number,\n  schema: NodeDesc,\n  contextProviderFactory: ContextProviderFactory\n): Promise<CompletionOption[]> {\n  // Fix the input to work around YAML parsing issues\n  const [newInput, newPos, partialInput] = _transform(input, pos);\n\n  // Parse with fixed text\n  const doc = await parse(filename, newInput, schema, contextProviderFactory);\n  if (!doc.workflow) {\n    return [];\n  }\n\n  const node = findNode(doc.workflowST, newPos) as YNode;\n  const desc = doc.nodeToDesc.get(node);\n  if (desc) {\n    let completionOptions = await doComplete(\n      node,\n      desc,\n      input,\n      partialInput,\n      newPos,\n      doc,\n      contextProviderFactory\n    );\n    completionOptions = completionOptions || [];\n    completionOptions.sort((a, b) => a.value.localeCompare(b.value));\n    return completionOptions;\n  }\n\n  // No desc found, check if we are in a scalar node with an expression?\n  if (node.kind === Kind.SCALAR) {\n    return expressionComplete(\n      node,\n      pos,\n      getPathFromNode(node),\n      doc.workflow,\n      contextProviderFactory\n    );\n  }\n\n  throw new Error(\"Could not find schema for node\");\n}\n","import {\n  Context,\n  ContextMember,\n  Dot,\n  ExpressionLexer,\n  Function,\n  defaultRule,\n  parser,\n} from \"./parser\";\nimport { PropertyPath, iteratePath } from \"../utils/path\";\n\nimport { CompletionOption } from \"../../types\";\nimport { ContextProvider } from \"./types\";\nimport { getFunctionDescription } from \"./functions\";\nimport { tokenMatcher } from \"chevrotain\";\n\nexport function inExpression(input: string, pos: number) {\n  return input.substring(0, pos).indexOf(\"${{\") !== -1;\n}\n\nexport async function completeExpression(\n  input: string,\n  pos: number,\n  contextProvider: ContextProvider\n): Promise<CompletionOption[]> {\n  input = input.substring(0, pos + 1);\n  // console.log(input);\n\n  const lexResult = ExpressionLexer.tokenize(input);\n  if (lexResult.errors.length > 0) {\n    return [];\n  }\n\n  let partialTokenVector = lexResult.tokens;\n  if (!partialTokenVector || partialTokenVector.length === 0) {\n    // Nothing to suggest in this case, abort\n    return [];\n  }\n\n  const lastInputToken = partialTokenVector[partialTokenVector.length - 1];\n\n  // Check if we are auto-completing a context access\n  if (\n    tokenMatcher(lastInputToken, ContextMember) ||\n    (tokenMatcher(lastInputToken, Dot) &&\n      (tokenMatcher(\n        partialTokenVector[partialTokenVector.length - 2],\n        Context\n      ) ||\n        tokenMatcher(\n          partialTokenVector[partialTokenVector.length - 2],\n          ContextMember\n        )))\n  ) {\n    // Determine previous context\n    const searchTerm = tokenMatcher(lastInputToken, Dot)\n      ? \"\"\n      : lastInputToken.image;\n\n    // Get context access path\n    let contextName: string | undefined;\n    let path: PropertyPath = [];\n    for (let i = partialTokenVector.length - 1; i >= 0; --i) {\n      if (tokenMatcher(partialTokenVector[i], Dot)) {\n        // Ignore .\n      } else {\n        if (tokenMatcher(partialTokenVector[i], ContextMember)) {\n          path.push(partialTokenVector[i].image);\n        } else if (tokenMatcher(partialTokenVector[i], Context)) {\n          contextName = partialTokenVector[i].image;\n        } else {\n          break;\n        }\n      }\n    }\n\n    // We iterate over the token vector backwards, so reverse the path for the\n    // actual context access\n    path = path.reverse();\n\n    if (contextName) {\n      const context = contextProvider.get(contextName as any);\n      const obj = iteratePath(\n        path[path.length - 1] === searchTerm\n          ? path.slice(0, path.length - 1)\n          : path,\n        context\n      );\n      const options = Object.keys(obj).map((x) => ({ value: x }));\n      options.sort((a, b) => a.value.localeCompare(b.value));\n      return options.filter(\n        (x) =>\n          !searchTerm ||\n          (x.value.startsWith(searchTerm) && x.value !== searchTerm)\n      );\n    }\n  }\n\n  // Check for auto-completing a context or a function\n  if (lastInputToken !== undefined) {\n    partialTokenVector = partialTokenVector.slice(0, -1);\n    const syntacticSuggestions = parser.computeContentAssist(\n      defaultRule,\n      partialTokenVector\n    );\n\n    const searchTerm = lastInputToken.image;\n    return syntacticSuggestions\n      .filter((x) => {\n        return (\n          Function.categoryMatchesMap?.[x.nextTokenType.tokenTypeIdx!] ||\n          Context.categoryMatchesMap?.[x.nextTokenType.tokenTypeIdx!]\n        );\n      })\n      .map((x) => (x.nextTokenType.PATTERN as RegExp).source)\n      .filter((x) => !searchTerm || x.startsWith(searchTerm))\n      .map((x) => ({\n        value: x,\n        description: getFunctionDescription(x),\n      }));\n  }\n\n  return [];\n}\n","import { Hover, Kind, YNode } from \"../../types\";\nimport { findNode, getPathFromNode, inPos } from \"./ast\";\n\nimport { ContextProviderFactory } from \"./complete\";\nimport { NodeDesc } from \"./schema\";\nimport { Workflow } from \"../workflow\";\nimport { containsExpression } from \"../expressions/embedding\";\nimport { parse } from \"./parser\";\nimport { replaceExpressions } from \"../expressions\";\n\nasync function doHover(\n  node: YNode,\n  desc: NodeDesc,\n  pos: number,\n  workflow: Workflow | undefined,\n  contextProviderFactory: ContextProviderFactory\n): Promise<Hover | undefined> {\n  switch (desc.type) {\n    case \"value\": {\n      // Expressions\n      if (node.kind === Kind.SCALAR && containsExpression(node.value)) {\n        const result = replaceExpressions(\n          node.value,\n          await contextProviderFactory.get(workflow, getPathFromNode(node))\n        );\n        if (result !== undefined) {\n          return {\n            description: `Evaluates to: \\`${result}\\``,\n          };\n        }\n      }\n\n      // Allowed values\n      if (desc.allowedValues) {\n        const allowedValue = desc.allowedValues.find((x) => node.value);\n        if (allowedValue && allowedValue.description) {\n          return {\n            description: allowedValue.description,\n          };\n        }\n      }\n\n      break;\n    }\n\n    case \"sequence\": {\n      if (node.kind !== Kind.SEQ) {\n        if (desc.itemDesc) {\n          return doHover(\n            node,\n            desc.itemDesc,\n            pos,\n            workflow,\n            contextProviderFactory\n          );\n        }\n      }\n\n      break;\n    }\n\n    case \"map\": {\n      if (node.kind === Kind.MAP) {\n        const mapping = node.mappings?.find((m) =>\n          inPos([m.startPosition, m.endPosition], pos)\n        );\n        if (mapping) {\n          const key = mapping.key?.value;\n          if (key) {\n            // We're hovering on a key\n\n            // Key is in schema\n            if (desc.keys?.[key]?.description) {\n              return {\n                description: desc.keys![key].description || \"\",\n              };\n            }\n\n            if (desc.customValueProvider) {\n              try {\n                const customValues = await desc.customValueProvider(\n                  desc,\n                  workflow,\n                  getPathFromNode(node)\n                );\n                const matchingValue = customValues?.find(\n                  (x) => x.value === key\n                );\n                if (matchingValue?.description) {\n                  return {\n                    description: matchingValue.description,\n                  };\n                }\n              } catch (e) {\n                // Log, but ignore custom values in case of error\n                console.error(e);\n              }\n            }\n          }\n        }\n      }\n      break;\n    }\n  }\n\n  if (desc.description) {\n    return {\n      description: desc.description,\n    };\n  }\n}\n\nexport async function hover(\n  filename: string,\n  input: string,\n  pos: number,\n  schema: NodeDesc,\n  contextProviderFactory: ContextProviderFactory\n): Promise<Hover | undefined> {\n  const doc = await parse(filename, input, schema, contextProviderFactory);\n\n  const node = findNode(doc.workflowST, pos) as YNode;\n  const desc = doc.nodeToDesc.get(node);\n  if (desc) {\n    return doHover(node, desc, pos, doc.workflow, contextProviderFactory);\n  }\n}\n","// From https://stackoverflow.com/a/34749873/561159\n\n/**\n * Simple object check.\n * @param item\n * @returns {boolean}\n */\nexport function isObject(item) {\n  return item && typeof item === \"object\" && !Array.isArray(item);\n}\n\n/**\n * Deep merge two objects.\n * @param target\n * @param ...sources\n */\nexport function mergeDeep<Q extends {}, T = any>(target: Q, ...sources: T[]) {\n  if (!sources.length) return target;\n  const source = sources.shift();\n\n  if (isObject(target) && isObject(source)) {\n    for (const key in source) {\n      if (isObject(source[key])) {\n        if (!target[key as string]) Object.assign(target, { [key]: {} });\n        mergeDeep(target[key as string], source[key]);\n      } else {\n        Object.assign(target, { [key]: source[key] });\n      }\n    }\n  }\n\n  return mergeDeep(target, ...sources);\n}\n","import check_run from \"../../events/check_run.json\";\nimport check_suite from \"../../events/check_suite.json\";\nimport commit_comment from \"../../events/commit_comment.json\";\nimport content_reference from \"../../events/content_reference.json\";\nimport create from \"../../events/create.json\";\nimport deletePayload from \"../../events/delete.json\";\nimport deploy_key from \"../../events/deploy_key.json\";\nimport deployment from \"../../events/deployment.json\";\nimport deployment_status from \"../../events/deployment_status.json\";\nimport fork from \"../../events/fork.json\";\nimport github_app_authorization from \"../../events/github_app_authorization.json\";\nimport gollum from \"../../events/gollum.json\";\nimport installation from \"../../events/installation.json\";\nimport installation_repositories from \"../../events/installation_repositories.json\";\nimport issue_comment from \"../../events/issue_comment.json\";\nimport issues from \"../../events/issues.json\";\nimport label from \"../../events/label.json\";\nimport marketplace_purchase from \"../../events/marketplace_purchase.json\";\nimport member from \"../../events/member.json\";\nimport membership from \"../../events/membership.json\";\nimport { mergeDeep } from \"../utils/deepMerge\";\nimport meta from \"../../events/meta.json\";\nimport milestone from \"../../events/milestone.json\";\nimport org_block from \"../../events/org_block.json\";\nimport organization from \"../../events/organization.json\";\nimport packagePayload from \"../../events/package.json\";\nimport page_build from \"../../events/page_build.json\";\nimport ping from \"../../events/ping.json\";\nimport project from \"../../events/project.json\";\nimport project_card from \"../../events/project_card.json\";\nimport project_column from \"../../events/project_column.json\";\nimport publicPayload from \"../../events/public.json\";\nimport pull_request from \"../../events/pull_request.json\";\nimport pull_request_review from \"../../events/pull_request_review.json\";\nimport pull_request_review_comment from \"../../events/pull_request_review_comment.json\";\nimport push from \"../../events/push.json\";\nimport release from \"../../events/release.json\";\nimport repository from \"../../events/repository.json\";\nimport repository_dispatch from \"../../events/repository_dispatch.json\";\nimport repository_import from \"../../events/repository_import.json\";\nimport repository_vulnerability_alert from \"../../events/repository_vulnerability_alert.json\";\nimport security_advisory from \"../../events/security_advisory.json\";\nimport sponsorship from \"../../events/sponsorship.json\";\nimport star from \"../../events/star.json\";\nimport status from \"../../events/status.json\";\nimport team from \"../../events/team.json\";\nimport team_add from \"../../events/team_add.json\";\nimport watch from \"../../events/watch.json\";\nimport workflow_dispatch from \"../../events/workflow_dispatch.json\";\nimport workflow_run from \"../../events/workflow_run.json\";\n\nconst eventPayloads = {\n  check_run,\n  check_suite,\n  commit_comment,\n  content_reference,\n  create,\n  delete: deletePayload,\n  deploy_key,\n  deployment,\n  deployment_status,\n  fork,\n  github_app_authorization,\n  gollum,\n  installation,\n  installation_repositories,\n  issue_comment,\n  issues,\n  label,\n  marketplace_purchase,\n  member,\n  membership,\n  meta,\n  milestone,\n  org_block,\n  organization,\n  package: packagePayload,\n  page_build,\n  ping,\n  project,\n  project_card,\n  project_column,\n  public: publicPayload,\n  pull_request,\n  pull_request_review,\n  pull_request_review_comment,\n  pull_request_target: pull_request,\n  push,\n  release,\n  repository,\n  repository_dispatch,\n  repository_import,\n  repository_vulnerability_alert,\n  security_advisory,\n  sponsorship,\n  star,\n  status,\n  team,\n  team_add,\n  watch,\n  workflow_dispatch,\n  workflow_run,\n};\n\nexport function getEventPayload(events: string[]) {\n  const payloads = events.map((event) => eventPayloads[event]);\n  return mergeDeep({}, ...payloads);\n}\n","import { getEventPayload } from \"../events/eventPayload\";\nimport { replaceExpressions } from \"../expressions\";\nimport { containsExpression } from \"../expressions/embedding\";\nimport { Undetermined } from \"../expressions/functions\";\nimport { ContextProvider, DynamicContext } from \"../expressions/types\";\nimport { mergeDeep } from \"../utils/deepMerge\";\nimport { iteratePath, PropertyPath } from \"../utils/path\";\nimport { Job, Step, Workflow } from \"../workflow\";\n\nfunction getEvent(workflow: Workflow) {\n  if (workflow && workflow.on) {\n    const events = Object.keys(workflow.on);\n    const eventPayload = getEventPayload(events);\n\n    // Add dynamic properties\n    if (workflow?.on.workflow_dispatch) {\n      eventPayload[\"inputs\"] = {};\n\n      for (const inputName of Object.keys(\n        workflow.on.workflow_dispatch.inputs || {}\n      )) {\n        eventPayload[\"inputs\"][inputName] =\n          workflow.on.workflow_dispatch.inputs![inputName]?.default ||\n          \"<provided input>\";\n      }\n    }\n\n    return eventPayload;\n  }\n\n  // Default to push, since it's one of the most common payloads\n  return getEventPayload([\"push\"]);\n}\n\nfunction getJob(workflow: Workflow, path: PropertyPath): Job | undefined {\n  const jobsIdx = path.indexOf(\"jobs\");\n  if (jobsIdx === -1) {\n    return;\n  } else if (jobsIdx >= path.length - 2) {\n    return;\n  }\n\n  // [$, jobs, build, [steps, 0]]\n  return iteratePath(path.slice(0, jobsIdx + 2), workflow) as Job;\n}\n\nexport class EditContextProvider implements ContextProvider {\n  constructor(\n    private workflow: Workflow,\n    private path: PropertyPath,\n    private secrets: string[] | typeof DynamicContext\n  ) {}\n\n  get(\n    context:\n      | \"github\"\n      | \"env\"\n      | \"job\"\n      | \"steps\"\n      | \"runner\"\n      | \"secrets\"\n      | \"strategy\"\n      | \"matrix\"\n      | \"needs\"\n  ): Object {\n    switch (context) {\n      case \"github\":\n        return {\n          event: getEvent(this.workflow),\n          event_path: \"\",\n          workflow: this.workflow?.name || \"workflow.yaml\",\n          job: \"\",\n          run_id: \"42\",\n          run_number: \"23\",\n          actor: \"monalisa\",\n          repository: \"repository\",\n          repository_owner: \"repository_owner\",\n          event_name:\n            (this.workflow?.on && Object.keys(this.workflow.on)[0]) || \"push\",\n          sha: \"6113728f27ae82c7b1a177c8d03f9e96e0adf246\",\n          ref: \"main\",\n          head_ref: \"refs/heads/branch\",\n          base_ref: \"refs/heads/main\",\n          token: \"***\",\n          workspace: \"\",\n          action: \"\",\n          action_path: \"\",\n        };\n\n      case \"env\":\n        let env = {};\n\n        if (this.workflow) {\n          iteratePath(this.path, this.workflow, (x) => {\n            if (x[\"env\"]) {\n              const newEnv = {\n                ...x[\"env\"],\n              };\n\n              for (const key of Object.keys(newEnv)) {\n                const value = newEnv[key];\n                if (containsExpression(value)) {\n                  try {\n                    newEnv[key] = replaceExpressions(value, {\n                      get: (context) => {\n                        if (context === \"env\") {\n                          return env;\n                        }\n\n                        return this.get(context);\n                      },\n                    });\n                  } catch (e) {\n                    // This is best effort, leave the expression as value\n                  }\n                }\n              }\n\n              env = {\n                ...env,\n                ...newEnv,\n              };\n            }\n          });\n        }\n\n        return env;\n\n      case \"runner\": {\n        return {\n          os: \"macOS\",\n          temp: \"/tmp\",\n          tool_cache: \"/tmp/cache\",\n        };\n      }\n\n      case \"job\": {\n        const job = getJob(this.workflow, this.path);\n        if (!job) {\n          return {};\n        }\n\n        return {\n          status: \"success\",\n          container: {\n            id: \"\",\n            network: \"\",\n          },\n          services: job.services,\n        };\n      }\n\n      case \"needs\": {\n        const job = getJob(this.workflow, this.path);\n        if (!job) {\n          return {};\n        }\n\n        return (\n          job.needs?.reduce((r, jobId) => {\n            const outputs: { [key: string]: any } =\n              this.workflow.jobs[jobId].outputs || {};\n\n            for (const output of Object.keys(outputs)) {\n              if (containsExpression(outputs[output])) {\n                // If the output reference another expression, mark it as undetermined for now.\n                outputs[output] = Undetermined;\n              }\n            }\n\n            return {\n              ...r,\n              [jobId]: {\n                result: \"success\",\n                outputs,\n              },\n            };\n          }, {}) || {}\n        );\n      }\n\n      case \"matrix\": {\n        const job = getJob(this.workflow, this.path);\n        if (!job) {\n          return {};\n        }\n\n        if (job.strategy?.matrix) {\n          if (typeof job.strategy.matrix === \"string\" /* Expression */) {\n            // Matrix is an expression, mark this as a dynamic context. Currently we cannot reason about those\n            return DynamicContext;\n          }\n\n          // Merge all values to all invocations. Not all of them will be available all the time, but for\n          // validation (and completion) purposes this is good enough\n          return mergeDeep({}, ...job.strategy.matrix);\n        }\n\n        return {};\n      }\n\n      case \"strategy\": {\n        const job = getJob(this.workflow, this.path);\n        return job?.strategy || {};\n      }\n\n      case \"steps\": {\n        // Check if we are in a step\n        const stepsIdx = this.path\n          .map((x) => (Array.isArray(x) ? x[0] : x))\n          .indexOf(\"steps\");\n        if (stepsIdx === -1) {\n          return {};\n        }\n\n        // Find the current job\n        const job = getJob(this.workflow, this.path);\n        if (!job) {\n          return {};\n        }\n\n        // Find the current step\n        const step = iteratePath(\n          this.path.slice(0, stepsIdx + 1),\n          this.workflow\n        ) as Step;\n\n        const stepIdx = job.steps.indexOf(step);\n        if (stepIdx === -1) {\n          return {};\n        }\n\n        // Iterate over all previous steps\n        return job.steps.slice(0, stepIdx + 1).reduce(\n          (r, step, stepIdx) => ({\n            ...r,\n            [step.id || `${stepIdx}`]: {\n              outputs: DynamicContext, // They might come from an action, we cannot determine those\n              outcome: \"success\",\n              conclusion: \"success\",\n            },\n          }),\n          {}\n        );\n      }\n\n      case \"secrets\":\n        if (!Array.isArray(this.secrets)) {\n          return DynamicContext;\n        }\n\n        return this.secrets.reduce((s, name) => {\n          s[name] = \"***\";\n          return s;\n        }, {});\n    }\n  }\n}\n","import { Context } from \"../../types\";\nimport { ContextProviderFactory } from \"../parser/complete\";\nimport { DynamicContext } from \"../expressions/types\";\nimport { EditContextProvider } from \"./contextProvider\";\nimport { PropertyPath } from \"../utils/path\";\nimport { TTLCache } from \"../utils/cache\";\nimport { Workflow } from \"../workflow\";\n\nexport function _getContextProviderFactory(\n  context: Context,\n  cache: TTLCache\n): ContextProviderFactory {\n  return {\n    get: async (workflow: Workflow, path: PropertyPath) => {\n      let secrets: string[] | typeof DynamicContext;\n\n      try {\n        secrets = await cache.get(\n          `${context.owner}/${context.repository}/secrets`,\n          context.timeToCacheResponsesInMS,\n          async () => {\n            if (!context?.client?.actions) {\n              return DynamicContext;\n            }\n\n            // Use a set to dedupe repo and org secrets\n            const secrets = new Set<string>([\"GITHUB_TOKEN\"]);\n\n            // Get repo secrets\n            const p: Promise<unknown>[] = [];\n            p.push(\n              (async () => {\n                const repoSecretsResponse = await context.client.actions.listRepoSecrets(\n                  {\n                    owner: context.owner,\n                    repo: context.repository,\n                  }\n                );\n\n                repoSecretsResponse.data.secrets.forEach((x) =>\n                  secrets.add(x.name)\n                );\n              })()\n            );\n\n            // Get org secrets\n            if (context.ownerIsOrg && context.orgFeaturesEnabled) {\n              // Org secrets need more permissions and are more likely to fail. If we cannot get org secrets\n              // we still want to return the repo secrets.\n              p.push(\n                (async () => {\n                  try {\n                    const orgSecretsResponse = await context.client.actions.listOrgSecrets(\n                      {\n                        org: context.owner,\n                        repo: context.repository,\n                      }\n                    );\n\n                    orgSecretsResponse.data.secrets.forEach((x) =>\n                      secrets.add(x.name)\n                    );\n                  } catch (e) {\n                    console.error(e);\n                    secrets.add(\n                      `:: Could not retrieve org secrets {e.?message}`\n                    );\n                  }\n                })()\n              );\n            }\n\n            await Promise.all(p);\n\n            return Array.from(secrets.values());\n          }\n        );\n      } catch (e) {\n        // TODO: CS: Provide this error somehow to the caller to display to the user\n        console.error(e);\n        secrets = [\"GITHUB_TOKEN\", `:: Could not load secrets: ${e?.message}`];\n      }\n\n      return new EditContextProvider(workflow, path, secrets);\n    },\n  };\n}\n","import { NodeDescMap, ValueDesc } from \"../../parser/schema\";\n\nimport { mergeDeep } from \"../../utils/deepMerge\";\n\nconst _events: [string, string, ([string, string] | string)[]][] = [\n  [\n    \"check_run\",\n    \"Runs your workflow anytime the check_run event occurs. More than one activity type triggers this event. For information about the REST API, see https://developer.github.com/v3/checks/runs.\",\n    [\"created\", \"rerequested\", \"completed\", \"requested_action\"],\n  ],\n  [\n    \"check_suite\",\n    \"Runs your workflow anytime the check_suite event occurs. More than one activity type triggers this event. For information about the REST API, see https://developer.github.com/v3/checks/suites/.\",\n    [\"completed\", \"requested\", \"rerequested\"],\n  ],\n  [\n    \"create\",\n    \"Runs your workflow anytime someone creates a branch or tag, which triggers the create event. For information about the REST API, see https://developer.github.com/v3/git/refs/#create-a-reference.\",\n    [],\n  ],\n  [\n    \"delete\",\n    \"Runs your workflow anytime someone deletes a branch or tag, which triggers the delete event. For information about the REST API, see https://developer.github.com/v3/git/refs/#delete-a-reference.\",\n    [],\n  ],\n  [\n    \"deployment\",\n    \"Runs your workflow anytime someone creates a deployment, which triggers the deployment event. Deployments created with a commit SHA may not have a Git ref. For information about the REST API, see https://developer.github.com/v3/repos/deployments/.\",\n    [],\n  ],\n  [\n    \"deployment_status\",\n    \"Runs your workflow anytime a third party provides a deployment status, which triggers the deployment_status event. Deployments created with a commit SHA may not have a Git ref. For information about the REST API, see https://developer.github.com/v3/repos/deployments/#create-a-deployment-status.\",\n    [],\n  ],\n  [\n    \"fork\",\n    \"Runs your workflow anytime when someone forks a repository, which triggers the fork event. For information about the REST API, see https://developer.github.com/v3/repos/forks/#create-a-fork.\",\n    [],\n  ],\n  [\n    \"gollum\",\n    \"Runs your workflow when someone creates or updates a Wiki page, which triggers the gollum event.\",\n    [],\n  ],\n  [\n    \"issue_comment\",\n    \"Runs your workflow anytime the issue_comment event occurs. More than one activity type triggers this event. For information about the REST API, see https://developer.github.com/v3/issues/comments/.\",\n    [],\n  ],\n  [\n    \"issues\",\n    \"Runs your workflow anytime the issues event occurs. More than one activity type triggers this event. For information about the REST API, see https://developer.github.com/v3/issues.\",\n    [\n      [\"opened\", \"\"],\n      [\"edited\", \"\"],\n      [\"deleted\", \"\"],\n      [\"transferred\", \"\"],\n      [\"pinned\", \"\"],\n      [\"unpinned\", \"\"],\n      [\"closed\", \"\"],\n      [\"reopened\", \"\"],\n      [\"assigned\", \"\"],\n      [\"unassigned\", \"\"],\n      [\"labeled\", \"\"],\n      [\"unlabeled\", \"\"],\n      [\"locked\", \"\"],\n      [\"unlocked\", \"\"],\n      [\"milestoned\", \"\"],\n      [\"demilestoned\", \"\"],\n    ],\n  ],\n  [\n    \"label\",\n    \"Runs your workflow anytime the label event occurs. More than one activity type triggers this event. For information about the REST API, see https://developer.github.com/v3/issues/labels/.\",\n    [\"created\", \"edited\", \"deleted\"],\n  ],\n  [\n    \"member\",\n    \"Runs your workflow anytime the member event occurs. More than one activity type triggers this event. For information about the REST API, see https://developer.github.com/v3/repos/collaborators/.\",\n    [\"added\", \"edited\", \"deleted\"],\n  ],\n  [\n    \"milestone\",\n    \"Runs your workflow anytime the milestone event occurs. More than one activity type triggers this event. For information about the REST API, see https://developer.github.com/v3/issues/milestones/.\",\n    [\"created\", \"closed\", \"opened\", \"edited\", \"deleted\"],\n  ],\n  [\n    \"page_build\",\n    \"Runs your workflow anytime someone pushes to a GitHub Pages-enabled branch, which triggers the page_build event. For information about the REST API, see https://developer.github.com/v3/repos/pages/.\",\n    [],\n  ],\n  [\n    \"project\",\n    \"Runs your workflow anytime the project event occurs. More than one activity type triggers this event. For information about the REST API, see https://developer.github.com/v3/projects/.\",\n    [\"created\", \"updated\", \"closed\", \"reopened\", \"edited\", \"deleted\"],\n  ],\n  [\n    \"project_card\",\n    \"Runs your workflow anytime the project_card event occurs. More than one activity type triggers this event. For information about the REST API, see https://developer.github.com/v3/projects/cards.\",\n    [\"created\", \"moved\", \"converted\", \"edited\", \"deleted\"],\n  ],\n  [\n    \"project_column\",\n    \"Runs your workflow anytime the project_column event occurs. More than one activity type triggers this event. For information about the REST API, see https://developer.github.com/v3/projects/columns.\",\n    [\"created\", \"updated\", \"moved\", \"deleted\"],\n  ],\n  [\n    \"public\",\n    \"Runs your workflow anytime someone makes a private repository public, which triggers the public event. For information about the REST API, see https://developer.github.com/v3/repos/#edit.\",\n    [],\n  ],\n  [\n    \"pull_request\",\n    \"Runs your workflow anytime the pull_request event occurs. More than one activity type triggers this event. For information about the REST API, see https://developer.github.com/v3/pulls.\\nNote: Workflows do not run on private base repositories when you open a pull request from a forked repository.\\nWhen you create a pull request from a forked repository to the base repository, GitHub sends the pull_request event to the base repository and no pull request events occur on the forked repository.\\nWorkflows don't run on forked repositories by default. You must enable GitHub Actions in the Actions tab of the forked repository.\\nThe permissions for the GITHUB_TOKEN in forked repositories is read-only. For more information about the GITHUB_TOKEN, see https://help.github.com/en/articles/virtual-environments-for-github-actions.\",\n    [\n      [\"assigned\", \"\"],\n      [\"unassigned\", \"\"],\n      [\"labeled\", \"\"],\n      [\"unlabeled\", \"\"],\n      [\"opened\", \"\"],\n      [\"edited\", \"\"],\n      [\"closed\", \"\"],\n      [\"reopened\", \"\"],\n      [\"synchronize\", \"\"],\n      [\"ready_for_review\", \"\"],\n      [\"locked\", \"\"],\n      [\"unlocked\", \"\"],\n      [\"review_requested\", \"\"],\n      [\"review_request_removed\", \"\"],\n    ],\n  ],\n  [\n    \"pull_request_review\",\n    \"Runs your workflow anytime the pull_request_review event occurs. More than one activity type triggers this event. For information about the REST API, see https://developer.github.com/v3/pulls/reviews.\\nNote: Workflows do not run on private base repositories when you open a pull request from a forked repository.\\nWhen you create a pull request from a forked repository to the base repository, GitHub sends the pull_request event to the base repository and no pull request events occur on the forked repository.\\nWorkflows don't run on forked repositories by default. You must enable GitHub Actions in the Actions tab of the forked repository.\\nThe permissions for the GITHUB_TOKEN in forked repositories is read-only. For more information about the GITHUB_TOKEN, see https://help.github.com/en/articles/virtual-environments-for-github-actions.\",\n    [\"submitted\", \"edited\", \"dismissed\"],\n  ],\n  [\n    \"pull_request_review_comment\",\n    \"Runs your workflow anytime a comment on a pull request's unified diff is modified, which triggers the pull_request_review_comment event. More than one activity type triggers this event. For information about the REST API, see https://developer.github.com/v3/pulls/comments.\\nNote: Workflows do not run on private base repositories when you open a pull request from a forked repository.\\nWhen you create a pull request from a forked repository to the base repository, GitHub sends the pull_request event to the base repository and no pull request events occur on the forked repository.\\nWorkflows don't run on forked repositories by default. You must enable GitHub Actions in the Actions tab of the forked repository.\\nThe permissions for the GITHUB_TOKEN in forked repositories is read-only. For more information about the GITHUB_TOKEN, see https://help.github.com/en/articles/virtual-environments-for-github-actions.\",\n    [\"created\", \"edited\", \"deleted\"],\n  ],\n  [\n    \"pull_request_target\",\n    \"This event runs in the context of the base of the pull request, rather than in the merge commit as the `pull_request` event does. This prevents executing unsafe workflow code from the head of the pull request that could alter your repository or steal any secrets you use in your workflow. This event allows you to do things like create workflows that label and comment on pull requests based on the contents of the event payload.\",\n    [\n      [\"assigned\", \"\"],\n      [\"unassigned\", \"\"],\n      [\"labeled\", \"\"],\n      [\"unlabeled\", \"\"],\n      [\"opened\", \"\"],\n      [\"edited\", \"\"],\n      [\"closed\", \"\"],\n      [\"reopened\", \"\"],\n      [\"synchronize\", \"\"],\n      [\"ready_for_review\", \"\"],\n      [\"locked\", \"\"],\n      [\"unlocked\", \"\"],\n      [\"review_requested\", \"\"],\n      [\"review_request_removed\", \"\"],\n    ],\n  ],\n  [\n    \"push\",\n    \"Runs your workflow when someone pushes to a repository branch, which triggers the push event.\\nNote: The webhook payload available to GitHub Actions does not include the added, removed, and modified attributes in the commit object. You can retrieve the full commit object using the REST API. For more information, see https://developer.github.com/v3/repos/commits/#get-a-single-commit.\",\n    [],\n  ],\n  [\"registry_package\", \"\", []],\n  [\n    \"release\",\n    \"Runs your workflow anytime the release event occurs. More than one activity type triggers this event. For information about the REST API, see https://developer.github.com/v3/repos/releases/.\",\n    [\"published\", \"unpublished\", \"created\", \"edited\", \"deleted\", \"prereleased\"],\n  ],\n  [\"repository_dispatch\", \"\", []],\n  [\n    \"schedule\",\n    \"You can schedule a workflow to run at specific UTC times using POSIX cron syntax (https://pubs.opengroup.org/onlinepubs/9699919799/utilities/crontab.html#tag_20_25_07). Scheduled workflows run on the latest commit on the default or base branch. The shortest interval you can run scheduled workflows is once every 5 minutes.\\nNote: GitHub Actions does not support the non-standard syntax @yearly, @monthly, @weekly, @daily, @hourly, and @reboot.\\nYou can use crontab guru (https://crontab.guru/). to help generate your cron syntax and confirm what time it will run. To help you get started, there is also a list of crontab guru examples (https://crontab.guru/examples.html).\",\n    [],\n  ],\n  [\n    \"status\",\n    \"Runs your workflow anytime the status of a Git commit changes, which triggers the status event. For information about the REST API, see https://developer.github.com/v3/repos/statuses/.\",\n    [],\n  ],\n  [\n    \"watch\",\n    \"Runs your workflow anytime the watch event occurs. More than one activity type triggers this event. For information about the REST API, see https://developer.github.com/v3/activity/starring/.\",\n    [],\n  ],\n  [\"workflow_call\", \"Allows workflows to be reused by other workflows.\", []],\n  [\"workflow_dispatch\", \"\", []],\n  [\"workflow_run\", \"\", []],\n];\n\nexport const events: ValueDesc[] = _events.map(([value, description]) => ({\n  value,\n  description,\n}));\n\nconst tagBranchPathFilters: NodeDescMap = {\n  branches: {\n    type: \"sequence\",\n    itemDesc: {\n      type: \"value\",\n      // TODO: Suggest branches from the repo?\n    },\n  },\n  \"branches-ignore\": {\n    type: \"sequence\",\n    itemDesc: {\n      type: \"value\",\n      // TODO: Suggest branches from the repo?\n    },\n  },\n  tags: {\n    type: \"sequence\",\n    itemDesc: {\n      type: \"value\",\n      // TODO: Suggest tags from the repo?\n    },\n  },\n  \"tags-ignore\": {\n    type: \"sequence\",\n    itemDesc: {\n      type: \"value\",\n      // TODO: Suggest tags from the repo?\n    },\n  },\n  paths: {\n    type: \"sequence\",\n    itemDesc: {\n      type: \"value\",\n    },\n  },\n  \"paths-ignore\": {\n    type: \"sequence\",\n    itemDesc: {\n      type: \"value\",\n    },\n  },\n};\n\nexport const eventMap: NodeDescMap = mergeDeep(\n  {},\n  // Add all events to map\n  _events.reduce(\n    (map, [event, description, types]) => ({\n      ...map,\n      [event]: {\n        type: \"map\",\n        description: description,\n        keys:\n          (types.length > 0 && {\n            types: {\n              type: \"sequence\",\n              itemDesc: {\n                type: \"value\",\n                allowedValues: types.map((type) => ({\n                  value: Array.isArray(type) ? type[0] : type,\n                  description: Array.isArray(type) ? type[1] : undefined,\n                })),\n              },\n            },\n          }) ||\n          undefined,\n      },\n    }),\n    {}\n  ),\n  // Override specific ones with special properties\n  {\n    push: {\n      type: \"map\",\n      keys: {\n        ...tagBranchPathFilters,\n      },\n    },\n    pull_request: {\n      type: \"map\",\n      keys: {\n        ...tagBranchPathFilters,\n      },\n    },\n    pull_request_target: {\n      type: \"map\",\n      keys: {\n        ...tagBranchPathFilters,\n      },\n    },\n    schedule: {\n      type: \"sequence\",\n      itemDesc: {\n        type: \"map\",\n        keys: {\n          cron: {\n            type: \"value\",\n            // TODO: Validate cron\n            //customValidator: (node, x) => {},\n          },\n        },\n        required: [\"cron\"],\n      },\n    },\n    workflow_dispatch: {\n      type: \"map\",\n      description: \"Event that can be manually triggered\",\n      keys: {\n        inputs: {\n          type: \"map\",\n          itemDesc: {\n            type: \"map\",\n            keys: {\n              required: {\n                type: \"value\",\n              },\n              description: {\n                type: \"value\",\n              },\n              type: {\n                type: \"value\",\n                allowedValues: [\n                  { value: \"boolean\" },\n                  { value: \"string\" },\n                  { value: \"choice\" },\n                  { value: \"environment\" },\n                ],\n              },\n              options: {\n                type: \"sequence\",\n              },\n              default: {\n                type: \"value\",\n              },\n            },\n          },\n        },\n      },\n    },\n    workflow_call: {\n      type: \"map\",\n      description: \"Allows workflows to be reused by other workflows.\",\n      keys: {\n        inputs: {\n          type: \"map\",\n          description:\n            \"When using the `workflow_call` event, you can optionally specify inputs that are passed to the called workflow from the caller workflow.\",\n          itemDesc: {\n            type: \"map\",\n            keys: {\n              description: {\n                type: \"value\",\n                description: \"A string description of the input parameter.\",\n              },\n              deprecationMessage: {\n                type: \"value\",\n                description:\n                  \"A string shown to users using the deprecated input.\",\n              },\n              required: {\n                type: \"value\",\n                description:\n                  \"A boolean to indicate whether the action requires the input parameter. Set to true when the parameter is required.\",\n              },\n              type: {\n                description:\n                  \"Required if input is defined for the on.workflow_call keyword. The value of this parameter is a string specifying the data type of the input. This must be one of: boolean, number, or string.\",\n                type: \"value\",\n                allowedValues: [\n                  { value: \"boolean\" },\n                  { value: \"number\" },\n                  { value: \"string\" },\n                ],\n              },\n              default: {\n                type: \"value\",\n                description:\n                  \"The default value is used when an input parameter isn't specified in a workflow file.\",\n              },\n            },\n          },\n        },\n        secrets: {\n          description:\n            \"A map of the secrets that can be used in the called workflow. Within the called workflow, you can use the secrets context to refer to a secret.\",\n          type: \"map\",\n          itemDesc: {\n            type: \"map\",\n            keys: {\n              description: {\n                type: \"value\",\n                description: \"A string description of the secret.\",\n              },\n              required: {\n                type: \"value\",\n                description:\n                  \"A boolean to indicate whether the workflow requires the secret.\",\n              },\n            },\n          },\n        },\n      },\n    },\n  } as NodeDescMap\n);\n","import { CustomValueProvider } from \"../../parser/schema\";\n\nexport const NeedsCustomValueProvider: CustomValueProvider = async (\n  _,\n  workflow,\n  path\n) => {\n  const jobId = path[path.length - 2];\n  return (\n    (jobId &&\n      workflow?.jobs &&\n      Object.keys(workflow.jobs)\n        .filter((x) => x !== jobId)\n        .map((x) => ({\n          value: x,\n        }))) ||\n    []\n  );\n};\n","import {\n  CustomValue,\n  CustomValueProvider,\n  CustomValueValidation,\n  NodeDesc,\n} from \"../../parser/schema\";\nimport { PropertyPath, iteratePath } from \"../../utils/path\";\nimport { RemoteUses, Step, Workflow } from \"../../workflow\";\n\nimport { Context } from \"../../../types\";\nimport { TTLCache } from \"../../utils/cache\";\nimport { load } from \"js-yaml\";\n\nasync function getActionYamlContent(\n  context: Context,\n  uses: RemoteUses\n): Promise<string | undefined> {\n  if (context?.client?.repos) {\n    // TODO: CS: Think about how to surface API errors to consumers of the library. E.g., the token might\n    // be invalid, or it might not meet SSO requirements\n    let contentResp = await context.client.repos.getContent({\n      owner: uses.owner,\n      repo: uses.repository,\n      path: \"action.yml\",\n      ref: uses.ref,\n    });\n\n    if ((contentResp.status as any) === 404) {\n      // There isn't an API to easily get two different files, when we cannot find `action.yml`, look\n      // for `action.yaml`, too.\n      // It might be okay to make two calls in parallel but for now this seems to work.\n      contentResp = await context.client.repos.getContent({\n        owner: uses.owner,\n        repo: uses.repository,\n        path: \"action.yaml\",\n        ref: uses.ref,\n      });\n    }\n\n    if ((contentResp as any)?.data?.content) {\n      // Response is base64 encoded, so decode\n      const buff = Buffer.from((contentResp as any).data.content, \"base64\");\n      let text = buff.toString(\"utf-8\");\n      // Remove any null bytes - see https://github.com/cschleiden/vscode-github-actions/issues/42\n      text = text.replace(\"\\0\", \"\");\n      return text;\n    }\n  }\n\n  return undefined;\n}\n\nexport const actionsInputProvider = (\n  context: Context,\n  cache: TTLCache\n): CustomValueProvider => async (\n  _: NodeDesc,\n  workflow: Workflow | undefined,\n  path: PropertyPath\n): Promise<CustomValue[] | undefined> => {\n  if (!workflow) {\n    return [];\n  }\n\n  // jobs:\n  //   foo:\n  //     steps:\n  //     - uses: \"actions/checkout@v2\"\n  //       with:\n  //         | <- This is where this gets called\n\n  // First, find the `uses`. Strip of the last `with` in the path, need the step level\n  if (path[path.length - 1] === \"with\") {\n    path.pop();\n  }\n\n  const step = iteratePath(path, workflow) as Step;\n  if (!step || !(\"uses\" in step) || step.uses.type !== \"remote\") {\n    return [];\n  }\n\n  const uses = step.uses;\n\n  return cache.get<CustomValue[] | undefined>(\n    `${uses.owner}/${uses.repository}@${uses.ref}`,\n    // Cache actions parameters for a long time\n    1_000 * 60 * 60,\n    async (): Promise<CustomValue[] | undefined> => {\n      const text = await getActionYamlContent(context, uses);\n      if (text) {\n        try {\n          const { inputs } = load(text, {\n            json: true, // Support unicode characters in unquoted strings\n          });\n          if (inputs) {\n            return Object.keys(inputs).map((key) => ({\n              value: key,\n              description: `${\n                inputs[key].description || \"\"\n              } \\n\\nrequired: \\`${!!inputs[key].required}\\` \\n\\n${\n                (inputs[key].default && `default:\\`${inputs[key].default}\\``) ||\n                \"\"\n              }`,\n              validation: !!inputs[key].required\n                ? CustomValueValidation.Required\n                : CustomValueValidation.None,\n            }));\n          }\n        } catch (e) {\n          console.error(e);\n        }\n      }\n\n      return undefined;\n    }\n  );\n};\n","import { CompletionOption, Context, Hover } from \"../../types\";\nimport { complete as genericComplete } from \"../parser/complete\";\nimport { hover as genericHover } from \"../parser/hover\";\nimport { parse as genericParse, WorkflowDocument } from \"../parser/parser\";\nimport {\n  MapNodeDesc,\n  NodeDesc,\n  ValueDesc,\n  ValueNodeDesc,\n} from \"../parser/schema\";\nimport { TTLCache } from \"../utils/cache\";\nimport { _getContextProviderFactory } from \"./contextCompletion\";\nimport { eventMap, events } from \"./schema/events\";\nimport { NeedsCustomValueProvider } from \"./schema/needs\";\nimport { actionsInputProvider } from \"./valueProvider/actionsInputProvider\";\n\nconst cache = new TTLCache();\n\nconst value = (description?: string): NodeDesc => ({\n  type: \"value\",\n  description,\n});\n\nconst concurrencyGroupKey: ValueNodeDesc = {\n  type: \"value\",\n  description:\n    \"Concurreny group key. Expressions can use the `github` context.\",\n  supportsExpression: true,\n};\n\nconst concurrency: NodeDesc = {\n  type: \"oneOf\",\n  description:\n    \"Concurrency ensures that only a single job or workflow using the same concurrency group will run at a time.\",\n  oneOf: [\n    concurrencyGroupKey,\n    {\n      type: \"map\",\n      keys: {\n        group: concurrencyGroupKey,\n        \"cancel-in-progress\": {\n          type: \"value\",\n        },\n      },\n    },\n  ],\n};\n\nconst permissionValue: ValueNodeDesc = {\n  type: \"value\",\n  allowedValues: [{ value: \"read\" }, { value: \"write\" }, { value: \"none\" }],\n};\n\nconst permissions: NodeDesc = {\n  type: \"oneOf\",\n  description:\n    \"Concurrency ensures that only a single job or workflow using the same concurrency group will run at a time.\",\n  oneOf: [\n    {\n      type: \"value\",\n      allowedValues: [{ value: \"read-all\" }, { value: \"write-all\" }],\n    },\n    {\n      type: \"map\",\n      keys: {\n        actions: permissionValue,\n        checks: permissionValue,\n        contents: permissionValue,\n        deployments: permissionValue,\n        discussions: permissionValue,\n        \"id-token\": permissionValue,\n        issues: permissionValue,\n        packages: permissionValue,\n        pages: permissionValue,\n        \"pull-requests\": permissionValue,\n        \"repository-projects\": permissionValue,\n        \"security-events\": permissionValue,\n        statuses: permissionValue,\n      },\n    },\n  ],\n};\n\nconst env: MapNodeDesc = {\n  type: \"map\",\n  itemDesc: {\n    type: \"value\",\n  },\n};\n\nconst shell: NodeDesc = {\n  type: \"value\",\n  allowedValues: [\n    { value: \"bash\" },\n    { value: \"pwsh\" },\n    { value: \"python\" },\n    { value: \"sh\" },\n    { value: \"cmd\" },\n    { value: \"powershell\" },\n  ],\n  description:\n    \"https://help.github.com/en/actions/reference/workflow-syntax-for-github-actions#custom-shell\",\n};\n\nconst defaults: MapNodeDesc = {\n  type: \"map\",\n  keys: {\n    run: {\n      type: \"map\",\n      keys: {\n        shell,\n        \"working-directory\": value(),\n      },\n    },\n  },\n};\n\nconst container = (): NodeDesc => ({\n  type: \"map\",\n  keys: {\n    image: value(\n      \"The Docker image to use as the container to run the action. The value can be the Docker Hub image name or a public docker registry name.\"\n    ),\n    env,\n    ports: {\n      type: \"sequence\",\n      itemDesc: value(),\n      description: \"Sets an array of ports to expose on the container.\",\n    },\n    volumes: {\n      type: \"sequence\",\n      itemDesc: value(\"Pattern: ^[^:]+:[^:]+$\"),\n      description:\n        \"Sets an array of volumes for the container to use. You can use volumes to share data between services or other steps in a job. You can specify named Docker volumes, anonymous Docker volumes, or bind mounts on the host.\\nTo specify a volume, you specify the source and destination path: <source>:<destinationPath>\\nThe <source> is a volume name or an absolute path on the host machine, and <destinationPath> is an absolute path in the container.\",\n    },\n    options: value(\n      \"Additional Docker container resource options. For a list of options, see https://docs.docker.com/engine/reference/commandline/create/#options.\"\n    ),\n  },\n  required: [\"image\"],\n});\n\nconst runsOn = (context: Context): NodeDesc => ({\n  type: \"value\",\n  description:\n    \"The type of machine to run the job on. The machine can be either a GitHub-hosted runner, or a self-hosted runner.\",\n\n  supportsExpression: true,\n\n  customValueProvider: async () =>\n    cache.get<ValueDesc[]>(\n      `${context.owner}/${context.repository}/runs-on-labels`,\n      context.timeToCacheResponsesInMS,\n      async () => {\n        const labels = new Set<string>([\n          \"ubuntu-latest\",\n          \"ubuntu-20.04\",\n          \"ubuntu-18.04\",\n          \"ubuntu-16.04\",\n          \"windows-latest\",\n          \"windows-2019\",\n          \"windows-2022\",\n          \"macos-latest\",\n          \"macos-11\",\n          \"macos-10.15\",\n          \"self-hosted\",\n        ]);\n\n        if (context?.client?.actions) {\n          try {\n            const runnersResp =\n              await context.client.actions.listSelfHostedRunnersForRepo({\n                owner: context.owner,\n                repo: context.repository,\n              });\n\n            if (runnersResp && runnersResp.data.runners) {\n              runnersResp.data.runners.forEach((r) =>\n                (r as any)?.labels?.forEach((l: { name: string }) =>\n                  labels.add(l.name)\n                )\n              );\n            }\n          } catch (e) {\n            console.log(\n              `Error while retrieving runner labels, falling back to defaults`,\n              e\n            );\n          }\n        }\n\n        return Array.from(labels.values()).map((x) => ({\n          value: x,\n        }));\n      }\n    ),\n});\n\nconst environment = (context: Context): NodeDesc => ({\n  type: \"value\",\n  description:\n    \"The environment that the job references. All environment protection rules must pass before a job referencing the environment is sent to a runner.\",\n\n  supportsExpression: true,\n\n  customValueProvider: async () =>\n    cache.get<ValueDesc[] | undefined>(\n      `${context.owner}/${context.repository}/environment-names`,\n      context.timeToCacheResponsesInMS,\n      async () => {\n        if (context?.client?.repos) {\n          try {\n            const environmentsResp =\n              await context.client.repos.getAllEnvironments({\n                owner: context.owner,\n                repo: context.repository,\n              });\n\n            if (environmentsResp && environmentsResp.data.environments) {\n              return environmentsResp.data.environments.map((e) => ({\n                value: e.name,\n                description: e.protection_rules?.length\n                  ? `Protection rules:\\n${e.protection_rules\n                      .map((pr) => `- ${pr.type}`)\n                      .join(\n                        \"\\n\"\n                      )}\\n\\nLearn more: [Protection rules](https://docs.github.com/en/actions/reference/environments#environment-protection-rules)`\n                  : undefined,\n              }));\n            }\n          } catch (e) {\n            console.log(`Error while retrieving environments`, e);\n          }\n        }\n\n        // Return undefined so any value is allowed\n        return undefined;\n      }\n    ),\n});\n\nconst job = (context: Context): NodeDesc => ({\n  type: \"map\",\n  keys: {\n    name: value(\"Optional custom name for this job\"),\n    concurrency,\n    permissions,\n    env,\n    needs: {\n      type: \"oneOf\",\n      oneOf: [\n        {\n          type: \"value\",\n          customValueProvider: NeedsCustomValueProvider,\n        },\n        {\n          type: \"sequence\",\n          itemDesc: {\n            type: \"value\",\n            customValueProvider: NeedsCustomValueProvider,\n          },\n        },\n      ],\n    },\n    outputs: {\n      type: \"map\",\n    },\n    environment: {\n      description: `The environment that the job references. All environment protection rules must pass before a job referencing the environment is sent to a runner. For more information, see [Environments](https://docs.github.com/en/free-pro-team@latest/actions/reference/environments).\n\nYou can provide the environment as only the environment \\`name\\`, or as an environment object with the \\`name\\` and \\`url\\`.`,\n      type: \"oneOf\",\n      oneOf: [\n        environment(context),\n        {\n          type: \"map\",\n          keys: {\n            name: environment(context),\n            url: value(\n              `The URL maps to \\`environment_url\\` in the deployments API. For more information about the deployments API, see [Deployments](https://docs.github.com/en/free-pro-team@latest/rest/reference/repos#deployments).\\n\\nThe URL can be an expression and can use any context except for the \\`secrets\\` context.`\n            ),\n          },\n          required: [\"name\"],\n        },\n      ],\n    },\n    defaults,\n    if: {\n      type: \"value\",\n      isExpression: true,\n    },\n    \"timeout-minutes\": value(),\n    \"continue-on-error\": value(),\n    container: container(),\n    services: {\n      type: \"map\",\n      itemDesc: container(),\n      description:\n        \"Additional containers to host services for a job in a workflow. These are useful for creating databases or cache services like redis. The runner on the virtual machine will automatically create a network and manage the life cycle of the service containers.\\nWhen you use a service container for a job or your step uses container actions, you don't need to set port information to access the service. Docker automatically exposes all ports between containers on the same network.\\nWhen both the job and the action run in a container, you can directly reference the container by its hostname. The hostname is automatically mapped to the service name.\\nWhen a step does not use a container action, you must access the service using localhost and bind the ports.\",\n    },\n    \"runs-on\": {\n      type: \"oneOf\",\n      oneOf: [\n        runsOn(context),\n        {\n          type: \"sequence\",\n          itemDesc: runsOn(context),\n        },\n      ],\n      description:\n        \"The type of machine to run the job on. The machine can be either a GitHub-hosted runner, or a self-hosted runner.\",\n    },\n    steps: {\n      type: \"sequence\",\n      itemDesc: {\n        type: \"map\",\n        keys: {\n          id: value(\n            \"A unique identifier for the step. You can use the id to reference the step in contexts. For more information, see https://help.github.com/en/articles/contexts-and-expression-syntax-for-github-actions.\"\n          ),\n          if: {\n            type: \"value\",\n            isExpression: true,\n          },\n          name: value(\"Optional custom name for the step\"),\n          uses: value(),\n          run: value(\n            \"Runs command-line programs using the operating system's shell. If you do not provide a `name`, the step name will default to the text specified in the `run` command.\"\n          ),\n          \"working-directory\": value(),\n          shell,\n          with: {\n            type: \"map\",\n            customValueProvider: actionsInputProvider(context, cache),\n          },\n          env,\n          \"continue-on-error\": value(),\n          \"timeout-minutes\": value(),\n        },\n      },\n    },\n    strategy: {\n      type: \"map\",\n      keys: {\n        matrix: {\n          type: \"oneOf\",\n          oneOf: [\n            {\n              type: \"map\",\n              // A matrix can use user-defined keys\n              allowUnknownKeys: true,\n              // Generic matrix description\n              itemDesc: {\n                type: \"sequence\",\n              },\n              // Handle `include` and `exclude` specifically\n              keys: {\n                include: {\n                  type: \"sequence\",\n                  itemDesc: {\n                    type: \"map\",\n                  },\n                },\n                exclude: {\n                  type: \"sequence\",\n                  itemDesc: {\n                    type: \"map\",\n                  },\n                },\n              },\n            },\n            {\n              type: \"value\",\n              description:\n                \"A matrix strategy can also be set using an expression. For example: `matrix: ${{fromJSON(needs.job1.outputs.matrix)}}`\",\n            },\n          ],\n          description:\n            \"A build matrix is a set of different configurations of the virtual environment. For example you might run a job against more than one supported version of a language, operating system, or tool. Each configuration is a copy of the job that runs and reports a status.\\nYou can specify a matrix by supplying an array for the configuration options. For example, if the GitHub virtual environment supports Node.js versions 6, 8, and 10 you could specify an array of those versions in the matrix.\\nWhen you define a matrix of operating systems, you must set the required runs-on keyword to the operating system of the current job, rather than hard-coding the operating system name. To access the operating system name, you can use the matrix.os context parameter to set runs-on. For more information, see https://help.github.com/en/articles/contexts-and-expression-syntax-for-github-actions.\",\n        },\n        \"fail-fast\": value(\n          \"When set to true, GitHub cancels all in-progress jobs if any matrix job fails. Default: true\"\n        ),\n        \"max-parallel\": value(\n          \"The maximum number of jobs that can run simultaneously when using a matrix job strategy. By default, GitHub will maximize the number of jobs run in parallel depending on the available runners on GitHub-hosted virtual machines.\"\n        ),\n      },\n      required: [\"matrix\"],\n    },\n  },\n\n  required: [\"runs-on\", \"steps\"],\n});\n\nexport function _getSchema(context: Context): NodeDesc {\n  return {\n    type: \"map\",\n    keys: {\n      name: value(`Name of the workflow`),\n      concurrency,\n      defaults,\n      env,\n      permissions,\n      on: {\n        type: \"oneOf\",\n        oneOf: [\n          // Can be one of the events\n          {\n            type: \"value\",\n            allowedValues: events,\n          },\n          // Can be an array of events\n          {\n            type: \"sequence\",\n            itemDesc: {\n              type: \"value\",\n              allowedValues: events,\n            },\n          },\n          // Can be a map of events\n          {\n            type: \"map\",\n            keys: eventMap,\n          },\n        ],\n      },\n      jobs: {\n        type: \"map\",\n        itemDesc: job(context),\n      },\n    },\n\n    required: [\"on\", \"jobs\"],\n  };\n}\n\nexport async function parse(\n  context: Context,\n  filename: string,\n  input: string\n): Promise<WorkflowDocument> {\n  return genericParse(\n    filename,\n    input,\n    _getSchema(context),\n    _getContextProviderFactory(context, cache)\n  );\n}\n\nexport async function complete(\n  context: Context,\n  filename: string,\n  input: string,\n  pos: number\n): Promise<CompletionOption[]> {\n  return genericComplete(\n    filename,\n    input,\n    pos,\n    _getSchema(context),\n    _getContextProviderFactory(context, cache)\n  );\n}\n\nexport async function hover(\n  context: Context,\n  filename: string,\n  input: string,\n  pos: number\n): Promise<Hover | undefined> {\n  return genericHover(\n    filename,\n    input,\n    pos,\n    _getSchema(context),\n    _getContextProviderFactory(context, cache)\n  );\n}\n","interface CacheEntry<T> {\n  cachedAt: number;\n  content: T;\n}\n\nexport class TTLCache {\n  private cache = new Map<string, CacheEntry<unknown>>();\n\n  constructor(private defaultTTLinMS: number = 10 * 60 * 1000) {}\n\n  /**\n   *\n   * @param key Key to cache value under\n   * @param ttlInMS How long is the content valid. If optional, default value will be used\n   * @param getter Function to retrieve content if not in cache\n   */\n  async get<T>(\n    key: string,\n    ttlInMS: number | undefined,\n    getter: () => Promise<T>\n  ): Promise<T> {\n    const hasEntry = this.cache.has(key);\n    const e = hasEntry && this.cache.get(key);\n    if (\n      hasEntry &&\n      e &&\n      e.cachedAt > Date.now() - (ttlInMS || this.defaultTTLinMS)\n    ) {\n      return e.content as T;\n    }\n\n    try {\n      const content = await getter();\n\n      this.cache.set(key, {\n        cachedAt: Date.now(),\n        content,\n      });\n\n      return content;\n    } catch (e) {\n      this.cache.delete(key);\n      throw e;\n    }\n  }\n}\n"],"names":["expressionMarker","containsExpression","input","match","iterateExpressions","f","Array","from","matchAll","index","length","funcDescription","toJSON","Undetermined","True","chevrotain","name","pattern","False","Null","LParens","RParens","LSquare","RSquare","Comma","Dot","ContextMemberOrKeyword","NA","ContextMember","categories","Context","longer_alt","Contexts","map","c","RegExp","Operator","And","Or","Eq","NEq","LT","LTE","GT","GTE","Not","Function","contains","startsWith","endsWith","join","fromJSON","hashFiles","success","always","failure","format","cancelled","Functions","StringLiteral","NumberLiteral","allTokens","group","SKIPPED","ExpressionLexer","ExpressionParser","constructor","super","this","RULE","SUBRULE1","subExpression","LABEL","MANY","CONSUME","SUBRULE2","OPTION","OR","ALT","SUBRULE","logicalGrouping","functionCall","contextAccess","value","array","contextMember","contextDotMember","contextBoxMember","expression","MANY_SEP","SEP","DEF","OR1","functionParameters","OR2","filter","booleanValue","performSelfAnalysis","parser","BaseCstVisitor","getBaseCstVisitorConstructor","iteratePath","path","obj","p","ExpressionEvaluator","validateVisitor","ctx","context","result","visit","lhs","rhs","forEach","rhsOperand","idx","rhsResult","operator","_coerceValue","tokenMatcher","contextName","PATTERN","source","find","Error","cM","getContextValue","contextProvider","get","push","image","se","parameters","haystack","needle","isArray","indexOf","toLocaleLowerCase","JSON","stringify","parse","replace","slice","parseFloat","_removeQuotes","val","keepString","NaN","substring","evaluator","ExpressionError","lexErrors","parseErrors","x","message","evaluateExpression","_","g","lexResult","tokenize","tokens","cst","errors","replaceExpressions","Kind","DiagnosticKind","inPos","position","pos","findNode","node","startPosition","endPosition","n","kind","MAP","mapping","mappings","MAPPING","r","key","parent","SEQ","item","items","SCALAR","getPathFromNode","nodePath","unshift","shift","parseUses","ref","split","owner","repository","subdirectory","type","normalizeJob","job","strategy","_job$strategy","matrix","explicitMatrixKeys","Object","keys","matrixValues","explicitMatrixKey","invocations","inputs","inputKey","[object Object]","newResult","inputValue","crossProduct","toExclude","exclude","deepEqual","toInclude","include","findIndex","leftEqual","a","b","every","keyA","splice","normalizeMatrix","steps","step","uses","needs","keysA","DynamicContext","ExpressionValidator","dynamicNode","iterateContextPath","undefined","CustomValueValidation","bind","state","pact","prototype","callback","e","_settle","target","values","check","reject","kindToString","validateNode","nodeDesc","nodeToDesc","workflow","contextProviderFactory","diagnostics","reportTypeMismatch","expectedType","actualKind","allowedValues","scalarNode","customValueProvider","customValues","_customValues","Warning","set","isExpression","posOffset","expr","expressionPosition","removeExpressionMarker","console","error","validateExpression","validateExpressions","rawValue","supportsExpression","required","requiredKeys","validation","Required","missingKey","seenKeys","has","mapNode","allowUnknownKeys","allowedKeys","Set","unknownKeys","unknownKey","mappingNode","_interrupt","Map","mappingDesc","itemDesc","_exit","foundMatchingNode","oneOf","nDesc","filename","schema","jsYamlLoad","on","reduce","o","jobs","jobId","normalizeWorkflow","yamlRoot","safeLoad","isWarning","reason","mark","root","validate","validationResult","workflowST","s","_this","thenable","filterAndSortCompletionOptions","partialInput","options","existingValues","sort","localeCompare","expressionComplete","inputPos","expressionPos","expressionFound","exp","start","startPos","substr","partialTokenVector","lastInputToken","searchTerm","i","reverse","syntacticSuggestions","computeContentAssist","categoryMatchesMap","nextTokenType","tokenTypeIdx","_Context$categoryMatc","description","completeExpression","doComplete","desc","doc","searchInput","existingItems","inExpression","mapDesc","_exit2","completeMapKeys","validTypes","add","line","trim","getCurrentLine","getValidOneOfTypes","body","then","one","existingKeys","doHover","allowedValue","_node$mappings","m","_mapping$key","_desc$keys","_desc$keys$key","matchingValue","onFulfilled","isObject","mergeDeep","sources","assign","eventPayloads","commit_comment","create","delete","deploy_key","fork","github_app_authorization","gollum","installation_repositories","issue_comment","issues","membership","meta","org_block","package","page_build","ping","public","pull_request","pull_request_review","pull_request_review_comment","pull_request_target","repository_dispatch","repository_import","repository_vulnerability_alert","star","team_add","watch","workflow_dispatch","workflow_run","getEventPayload","events","event","getEvent","eventPayload","inputName","default","getJob","jobsIdx","EditContextProvider","secrets","event_path","run_id","run_number","actor","repository_owner","event_name","sha","head_ref","base_ref","token","workspace","action","action_path","env","newEnv","os","temp","tool_cache","status","container","id","network","services","outputs","output","stepsIdx","stepIdx","outcome","conclusion","_getContextProviderFactory","cache","timeToCacheResponsesInMS","client","_context$client","actions","listRepoSecrets","repo","repoSecretsResponse","data","ownerIsOrg","orgFeaturesEnabled","listOrgSecrets","org","orgSecretsResponse","Promise","all","_events","tagBranchPathFilters","branches","branches-ignore","tags","tags-ignore","paths","paths-ignore","eventMap","types","schedule","cron","workflow_call","deprecationMessage","NeedsCustomValueProvider","actionsInputProvider","pop","repos","getContent","contentResp","_contentResp","_contentResp$data","content","text","Buffer","toString","getActionYamlContent","load","json","None","hover","defaultTTLinMS","ttlInMS","getter","hasEntry","cachedAt","Date","now","concurrencyGroupKey","concurrency","cancel-in-progress","permissionValue","permissions","checks","contents","deployments","discussions","id-token","packages","pages","pull-requests","repository-projects","security-events","statuses","shell","defaults","run","working-directory","ports","volumes","runsOn","labels","listSelfHostedRunnersForRepo","runnersResp","runners","_r$labels","l","log","environment","_context$client2","getAllEnvironments","environmentsResp","environments","protection_rules","pr","url","if","timeout-minutes","continue-on-error","runs-on","with","fail-fast","max-parallel","_getSchema","newInput","newPos","lines","lineNo","linePos","colon","trimmedLine","spacer","_transform","completionOptions","genericComplete","genericHover","genericParse"],"mappings":"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"}